

const unknowna217fddf = 0
const unknownd5391393 = 0x9f2df0fed2c77648de5860a4cc508cd0818c85b8b8a1ab4ceeef8d981c8956a6
const unknowne63ab1e9 = 0x65d7a28e3265b37a6474929f336521b332c1681b933f6cb9f3376673440d862a

def storage:
  unknown248a9ca3 is mapping of struct at storage 0
  unknown9010d07c is array of struct at storage 1
  stor2 is array of struct at storage 2
  stor3 is array of struct at storage 3
  ownerOf is mapping of addr at storage 4
  balanceOf is mapping of uint256 at storage 5
  approved is mapping of addr at storage 6
  stor7 is mapping of uint8 at storage 7
  tokenOfOwnerByIndex is mapping of uint256 at storage 8
  stor9 is mapping of uint256 at storage 9
  tokenByIndex is array of uint256 at storage 10
  stor11 is mapping of uint256 at storage 11
  paused is uint8 at storage 12
  stor13 is uint256 at storage 13
  stor14 is array of struct at storage 14
  unknown1f0234d8 is uint8 at storage 15
  saleIsActive is uint8 at storage 15 offset 8

def getApproved(uint256 _tokenId) payable: 
  require calldata.size - 4 >=′ 32
  if not ownerOf[_tokenId]:
      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: approved query for nonexistent token'
  return approved[_tokenId]

def totalSupply() payable: 
  return tokenByIndex.length

def unknown1f0234d8() payable: 
  return bool(unknown1f0234d8)

def unknown248a9ca3(uint256 _param1) payable: 
  require calldata.size - 4 >=′ 32
  return unknown248a9ca3[_param1].field_256

def tokenOfOwnerByIndex(address _owner, uint256 _index) payable: 
  require calldata.size - 4 >=′ 64
  require _owner == _owner
  if not _owner:
      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: balance query for the zero address'
  if _index >= balanceOf[addr(_owner)]:
      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721Enumerable: owner index out of bounds'
  return tokenOfOwnerByIndex[addr(_owner)][_index]

def tokenByIndex(uint256 _index) payable: 
  require calldata.size - 4 >=′ 32
  if _index >= tokenByIndex.length:
      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721Enumerable: global index out of bounds'
  return tokenByIndex[_index]

def paused() payable: 
  return bool(paused)

def ownerOf(uint256 _tokenId) payable: 
  require calldata.size - 4 >=′ 32
  if not ownerOf[_tokenId]:
      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: owner query for nonexistent token'
  return ownerOf[_tokenId]

def balanceOf(address _owner) payable: 
  require calldata.size - 4 >=′ 32
  require _owner == _owner
  if not _owner:
      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: balance query for the zero address'
  return balanceOf[addr(_owner)]

def unknown9010d07c(uint256 _param1, uint256 _param2) payable: 
  require calldata.size - 4 >=′ 64
  if _param2 >= unknown9010d07c[_param1].field_0:
      revert with 0, 50
  return unknown9010d07c[_param1][_param2].field_0

def unknown91d14854(uint256 _param1, uint256 _param2) payable: 
  require calldata.size - 4 >=′ 64
  require _param2 == addr(_param2)
  return bool(unknown248a9ca3[_param1][addr(_param2)].field_0)

def unknownca15c873(uint256 _param1) payable: 
  require calldata.size - 4 >=′ 32
  return unknown9010d07c[_param1].field_0

def isApprovedForAll(address _owner, address _operator) payable: 
  require calldata.size - 4 >=′ 64
  require _owner == _owner
  require _operator == _operator
  return bool(stor7[addr(_owner)][addr(_operator)])

def saleIsActive() payable: 
  return bool(saleIsActive)

#
#  Regular functions
#

def _fallback() payable: # default function
  revert

def pause() payable: 
  if not unknown248a9ca3[0x65d7a28e3265b37a6474929f336521b332c1681b933f6cb9f3376673440d862a][caller].field_0:
      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                  'ERC721PresetMinterPauserAutoId: must have pauser role to pause'
  if paused:
      revert with 0, 'Pausable: paused'
  paused = 1
  log Paused(address account=caller)

def unpause() payable: 
  if not unknown248a9ca3[0x65d7a28e3265b37a6474929f336521b332c1681b933f6cb9f3376673440d862a][caller].field_0:
      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                  'ERC721PresetMinterPauserAutoId: must have pauser role to unpause'
  if not paused:
      revert with 0, 'Pausable: not paused'
  paused = 0
  log Unpaused(address account=caller)

def setApprovalForAll(address _to, bool _approved) payable: 
  require calldata.size - 4 >=′ 64
  require _to == _to
  require _approved == _approved
  if not caller - _to:
      revert with 0, 'ERC721: approve to caller'
  stor7[caller][addr(_to)] = uint8(_approved)
  log ApprovalForAll(
        address owner=_approved,
        address operator=caller,
        bool approved=_to)

def supportsInterface(bytes4 _interfaceId) payable: 
  require calldata.size - 4 >=′ 32
  require _interfaceId == Mask(32, 224, _interfaceId)
  if 0x780e9d6300000000000000000000000000000000000000000000000000000000 == Mask(32, 224, _interfaceId):
      return True
  if 0x80ac58cd00000000000000000000000000000000000000000000000000000000 == Mask(32, 224, _interfaceId):
      return True
  if 0x5b5e139f00000000000000000000000000000000000000000000000000000000 == Mask(32, 224, _interfaceId):
      return True
  if 0x5a05180f00000000000000000000000000000000000000000000000000000000 == Mask(32, 224, _interfaceId):
      return True
  if 0x7965db0b00000000000000000000000000000000000000000000000000000000 == Mask(32, 224, _interfaceId):
      return True
  return (Mask(32, 224, _interfaceId) == 0x1ffc9a700000000000000000000000000000000000000000000000000000000)

def approve(address _spender, uint256 _value) payable: 
  require calldata.size - 4 >=′ 64
  require _spender == _spender
  if not ownerOf[_value]:
      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: owner query for nonexistent token'
  if not _spender - ownerOf[_value]:
      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: approval to current owner'
  if ownerOf[_value] != caller:
      if not stor7[stor4[_value]][caller]:
          revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                      'ERC721: approve caller is not owner nor approved for all'
  approved[_value] = _spender
  if not ownerOf[_value]:
      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: owner query for nonexistent token'
  log Approval(
        address tokenOwner=ownerOf[_value],
        address spender=_spender,
        uint256 tokens=_value)

def unknown3423e548() payable: 
  require calldata.size - 4 >=′ 96
  require cd[68] <= 18446744073709551615
  require cd[68] + 35 <′ calldata.size
  if ('cd', 68).length > 18446744073709551615:
      revert with 0, 65
  if ceil32(32 * ('cd', 68).length) + 97 < 96 or ceil32(32 * ('cd', 68).length) + 97 > 18446744073709551615:
      revert with 0, 65
  mem[64] = ceil32(32 * ('cd', 68).length) + 97
  mem[96] = ('cd', 68).length
  require (32 * ('cd', 68).length) + cd[68] + 36 <= calldata.size
  s = 128
  idx = cd[68] + 36
  while idx < (32 * ('cd', 68).length) + cd[68] + 36:
      mem[s] = cd[idx]
      s = s + 32
      idx = idx + 32
      continue 
  idx = 0
  s = cd[4]
  while idx < ('cd', 68).length:
      if idx >= mem[96]:
          revert with 0, 50
      _31 = mem[(32 * idx) + 128]
      if s > mem[(32 * idx) + 128]:
          mem[mem[64] + 32] = mem[(32 * idx) + 128]
          mem[mem[64] + 64] = s
          _34 = mem[64]
          mem[mem[64]] = 64
          mem[64] = mem[64] + 96
          if not idx + 1:
              revert with 0, 17
          idx = idx + 1
          s = sha3(mem[_34 + 32 len mem[_34]])
          continue 
      mem[mem[64] + 32] = s
      mem[mem[64] + 64] = _31
      _38 = mem[64]
      mem[mem[64]] = 64
      mem[64] = mem[64] + 96
      if not idx + 1:
          revert with 0, 17
      idx = idx + 1
      s = sha3(mem[_38 + 32 len mem[_38]])
      continue 
  return (cd[36] == s)

def mint(address _to) payable: 
  require calldata.size - 4 >=′ 32
  require _to == _to
  if not saleIsActive:
      revert with 0, 'Sale is not currently active.'
  if not unknown248a9ca3[0x9f2df0fed2c77648de5860a4cc508cd0818c85b8b8a1ab4ceeef8d981c8956a6][caller].field_0:
      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                  'ERC721PresetMinterPauserAutoId: must have minter role to mint'
  if not _to:
      revert with 0, 'ERC721: mint to the zero address'
  if ownerOf[stor13]:
      revert with 0, 'ERC721: token already minted'
  stor11[stor13] = tokenByIndex.length
  tokenByIndex.length++
  tokenByIndex[tokenByIndex.length] = stor13
  if _to:
      if _to:
          if not _to:
              revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: balance query for the zero address'
          tokenOfOwnerByIndex[addr(_to)][stor5[addr(_to)]] = stor13
          stor9[stor13] = balanceOf[addr(_to)]
  else:
      if tokenByIndex.length - 1 > tokenByIndex.length:
          revert with 0, 17
      if tokenByIndex.length - 1 >= tokenByIndex.length:
          revert with 0, 50
      if stor11[stor13] >= tokenByIndex.length:
          revert with 0, 50
      tokenByIndex[stor11[stor13]] = tokenByIndex[tokenByIndex.length]
      stor11[stor10[stor10.length]] = stor11[stor13]
      stor11[stor13] = 0
      if not tokenByIndex.length:
          revert with 0, 49
      tokenByIndex[tokenByIndex.length] = 0
      tokenByIndex.length--
  if paused:
      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721Pausable: token transfer while paused'
  if balanceOf[addr(_to)] > balanceOf[addr(_to)] + 1:
      revert with 0, 17
  balanceOf[addr(_to)]++
  ownerOf[stor13] = _to
  log Transfer(
        address from=0,
        address to=_to,
        uint256 tokens=stor13)
  stor13++

def unknown2f2ff15d(uint256 _param1, uint256 _param2) payable: 
  require calldata.size - 4 >=′ 64
  require _param2 == addr(_param2)
  if not unknown248a9ca3[unknown248a9ca3[_param1].field_256][caller].field_0:
      mem[128 len 42] = call.data[calldata.size len 42]
      idx = 41
      s = caller
      while idx > 1:
          if s % 16 >= 16:
              revert with 0, 50
          if idx >= 42:
              revert with 0, 50
          mem[idx + 128 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
          if not idx:
              revert with 0, 17
          idx = idx - 1
          s = Mask(252, 0, s) * 0.0625
          continue 
      if caller + 10240:
          revert with 0, 'Strings: hex length insufficient'
      mem[224 len 66] = call.data[calldata.size len 66]
      idx = 65
      s = unknown248a9ca3[_param1].field_256
      while idx > 1:
          if s % 16 >= 16:
              revert with 0, 50
          if idx >= 66:
              revert with 0, 50
          mem[idx + 224 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
          if not idx:
              revert with 0, 17
          idx = idx - 1
          s = Mask(252, 0, s) * 0.0625
          continue 
      if unknown248a9ca3[_param1].field_256 + 16384:
          revert with 0, 'Strings: hex length insufficient'
      revert with 0, 32, 148, 'AccessControl: account ', mem[160 len 42], 8297, mem[288 len 66], 0, 0 >> 928, 0
  if not unknown248a9ca3[_param1][addr(_param2)].field_0:
      unknown248a9ca3[_param1][addr(_param2)].field_0 = 1
      log 0x2f878811: _param1, addr(_param2), caller
  if not unknown9010d07c[_param1][1][addr(_param2)].field_0:
      unknown9010d07c[_param1].field_0++
      unknown9010d07c[_param1][unknown9010d07c[_param1].field_0].field_0 = addr(_param2)
      unknown9010d07c[_param1][unknown9010d07c[_param1].field_0].field_160 = 0
      unknown9010d07c[_param1][1][addr(_param2)].field_0 = unknown9010d07c[_param1].field_0

def unknown36568abe(uint256 _param1, uint256 _param2) payable: 
  require calldata.size - 4 >=′ 64
  require _param2 == addr(_param2)
  if addr(_param2) != caller:
      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'AccessControl: can only renounce roles for self'
  if unknown248a9ca3[_param1][addr(_param2)].field_0:
      unknown248a9ca3[_param1][addr(_param2)].field_0 = 0
      log 0xf6391f5c: _param1, addr(_param2), caller
  if unknown9010d07c[_param1][1][addr(_param2)].field_0:
      if unknown9010d07c[_param1][1][addr(_param2)].field_0 - 1 > unknown9010d07c[_param1][1][addr(_param2)].field_0:
          revert with 0, 17
      if unknown9010d07c[_param1].field_0 - 1 > unknown9010d07c[_param1].field_0:
          revert with 0, 17
      if unknown9010d07c[_param1].field_0 - 1 != unknown9010d07c[_param1][1][addr(_param2)].field_0 - 1:
          if unknown9010d07c[_param1].field_0 - 1 >= unknown9010d07c[_param1].field_0:
              revert with 0, 50
          if unknown9010d07c[_param1][1][addr(_param2)].field_0 - 1 >= unknown9010d07c[_param1].field_0:
              revert with 0, 50
          unknown9010d07c[_param1][unknown9010d07c[_param1][1][addr(_param2)].field_0].field_0 = unknown9010d07c[_param1][unknown9010d07c[_param1].field_0].field_0
          unknown9010d07c[_param1][1][unknown9010d07c[_param1][unknown9010d07c[_param1].field_0].field_0].field_0 = unknown9010d07c[_param1][1][addr(_param2)].field_0
      if not unknown9010d07c[_param1].field_0:
          revert with 0, 49
      unknown9010d07c[_param1][unknown9010d07c[_param1].field_0].field_0 = 0
      unknown9010d07c[_param1].field_0--
      unknown9010d07c[_param1][1][addr(_param2)].field_0 = 0

def burn(uint256 _value) payable: 
  require calldata.size - 4 >=′ 32
  if not ownerOf[_value]:
      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: operator query for nonexistent token'
  if not ownerOf[_value]:
      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: owner query for nonexistent token'
  if ownerOf[_value] != caller:
      if not stor7[stor4[_value]][caller]:
          if not ownerOf[_value]:
              revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: approved query for nonexistent token'
          if approved[_value] != caller:
              revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721Burnable: caller is not owner nor approved'
  if not ownerOf[_value]:
      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: owner query for nonexistent token'
  if ownerOf[_value]:
      if not ownerOf[_value]:
          revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: balance query for the zero address'
      if balanceOf[stor4[_value]] - 1 > balanceOf[stor4[_value]]:
          revert with 0, 17
      if balanceOf[stor4[_value]] - 1 != stor9[_value]:
          tokenOfOwnerByIndex[stor4[_value]][stor9[_value]] = tokenOfOwnerByIndex[stor4[_value]][stor5[stor4[_value]] - 1]
          stor9[stor8[stor4[_value]][stor5[stor4[_value]] - 1]] = stor9[_value]
      stor9[_value] = 0
      tokenOfOwnerByIndex[stor4[_value]][stor5[stor4[_value]] - 1] = 0
  if tokenByIndex.length - 1 > tokenByIndex.length:
      revert with 0, 17
  if tokenByIndex.length - 1 >= tokenByIndex.length:
      revert with 0, 50
  if stor11[_value] >= tokenByIndex.length:
      revert with 0, 50
  tokenByIndex[stor11[_value]] = tokenByIndex[tokenByIndex.length]
  stor11[stor10[stor10.length]] = stor11[_value]
  stor11[_value] = 0
  if not tokenByIndex.length:
      revert with 0, 49
  tokenByIndex[tokenByIndex.length] = 0
  tokenByIndex.length--
  if paused:
      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721Pausable: token transfer while paused'
  approved[_value] = 0
  if not ownerOf[_value]:
      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: owner query for nonexistent token'
  log Approval(
        address tokenOwner=ownerOf[_value],
        address spender=0,
        uint256 tokens=_value)
  if balanceOf[stor4[_value]] - 1 > balanceOf[stor4[_value]]:
      revert with 0, 17
  balanceOf[stor4[_value]]--
  ownerOf[_value] = 0
  log Transfer(
        address from=ownerOf[_value],
        address to=0,
        uint256 tokens=_value)

def unknownd547741f(uint256 _param1, uint256 _param2) payable: 
  require calldata.size - 4 >=′ 64
  require _param2 == addr(_param2)
  if not unknown248a9ca3[unknown248a9ca3[_param1].field_256][caller].field_0:
      mem[128 len 42] = call.data[calldata.size len 42]
      idx = 41
      s = caller
      while idx > 1:
          if s % 16 >= 16:
              revert with 0, 50
          if idx >= 42:
              revert with 0, 50
          mem[idx + 128 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
          if not idx:
              revert with 0, 17
          idx = idx - 1
          s = Mask(252, 0, s) * 0.0625
          continue 
      if caller + 10240:
          revert with 0, 'Strings: hex length insufficient'
      mem[224 len 66] = call.data[calldata.size len 66]
      idx = 65
      s = unknown248a9ca3[_param1].field_256
      while idx > 1:
          if s % 16 >= 16:
              revert with 0, 50
          if idx >= 66:
              revert with 0, 50
          mem[idx + 224 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
          if not idx:
              revert with 0, 17
          idx = idx - 1
          s = Mask(252, 0, s) * 0.0625
          continue 
      if unknown248a9ca3[_param1].field_256 + 16384:
          revert with 0, 'Strings: hex length insufficient'
      revert with 0, 32, 148, 'AccessControl: account ', mem[160 len 42], 8297, mem[288 len 66], 0, 0 >> 928, 0
  if unknown248a9ca3[_param1][addr(_param2)].field_0:
      unknown248a9ca3[_param1][addr(_param2)].field_0 = 0
      log 0xf6391f5c: _param1, addr(_param2), caller
  if unknown9010d07c[_param1][1][addr(_param2)].field_0:
      if unknown9010d07c[_param1][1][addr(_param2)].field_0 - 1 > unknown9010d07c[_param1][1][addr(_param2)].field_0:
          revert with 0, 17
      if unknown9010d07c[_param1].field_0 - 1 > unknown9010d07c[_param1].field_0:
          revert with 0, 17
      if unknown9010d07c[_param1].field_0 - 1 != unknown9010d07c[_param1][1][addr(_param2)].field_0 - 1:
          if unknown9010d07c[_param1].field_0 - 1 >= unknown9010d07c[_param1].field_0:
              revert with 0, 50
          if unknown9010d07c[_param1][1][addr(_param2)].field_0 - 1 >= unknown9010d07c[_param1].field_0:
              revert with 0, 50
          unknown9010d07c[_param1][unknown9010d07c[_param1][1][addr(_param2)].field_0].field_0 = unknown9010d07c[_param1][unknown9010d07c[_param1].field_0].field_0
          unknown9010d07c[_param1][1][unknown9010d07c[_param1][unknown9010d07c[_param1].field_0].field_0].field_0 = unknown9010d07c[_param1][1][addr(_param2)].field_0
      if not unknown9010d07c[_param1].field_0:
          revert with 0, 49
      unknown9010d07c[_param1][unknown9010d07c[_param1].field_0].field_0 = 0
      unknown9010d07c[_param1].field_0--
      unknown9010d07c[_param1][1][addr(_param2)].field_0 = 0

def unknown0ef25b0f() payable: 
  require calldata.size - 4 >=′ 96
  require cd[4] == addr(cd[4])
  require cd[68] <= 18446744073709551615
  require cd[68] + 35 <′ calldata.size
  if ('cd', 68).length > 18446744073709551615:
      revert with 0, 65
  if ceil32(32 * ('cd', 68).length) + 97 < 96 or ceil32(32 * ('cd', 68).length) + 97 > 18446744073709551615:
      revert with 0, 65
  mem[96] = ('cd', 68).length
  require (32 * ('cd', 68).length) + cd[68] + 36 <= calldata.size
  s = 128
  idx = cd[68] + 36
  while idx < (32 * ('cd', 68).length) + cd[68] + 36:
      mem[s] = cd[idx]
      s = s + 32
      idx = idx + 32
      continue 
  if not unknown1f0234d8:
      revert with 0, 'Presale is not currently active.'
  mem[ceil32(32 * ('cd', 68).length) + 129] = addr(cd[4])
  mem[ceil32(32 * ('cd', 68).length) + 97] = 20
  mem[64] = ceil32(32 * ('cd', 68).length) + 149
  idx = 0
  s = 0
  while idx < ('cd', 68).length:
      if idx >= mem[96]:
          revert with 0, 50
      _108 = mem[(32 * idx) + 128]
      if s + sha3(mem[ceil32(32 * ('cd', 68).length) + 129 len mem[ceil32(32 * ('cd', 68).length) + 97]]) > mem[(32 * idx) + 128]:
          mem[mem[64] + 32] = mem[(32 * idx) + 128]
          mem[mem[64] + 64] = s + sha3(mem[ceil32(32 * ('cd', 68).length) + 129 len mem[ceil32(32 * ('cd', 68).length) + 97]])
          _111 = mem[64]
          mem[mem[64]] = 64
          mem[64] = mem[64] + 96
          if not idx + 1:
              revert with 0, 17
          idx = idx + 1
          s = sha3(mem[_111 + 32 len mem[_111]])
          continue 
      mem[mem[64] + 32] = s + sha3(mem[ceil32(32 * ('cd', 68).length) + 129 len mem[ceil32(32 * ('cd', 68).length) + 97]])
      mem[mem[64] + 64] = _108
      _115 = mem[64]
      mem[mem[64]] = 64
      mem[64] = mem[64] + 96
      if not idx + 1:
          revert with 0, 17
      idx = idx + 1
      s = sha3(mem[_115 + 32 len mem[_115]])
      continue 
  if cd[36] != s:
      revert with 0, 'You are not on our pre-sale allow list!'
  if not addr(cd[4]):
      revert with 0, 'ERC721: mint to the zero address'
  if ownerOf[stor13]:
      revert with 0, 'ERC721: token already minted'
  stor11[stor13] = tokenByIndex.length
  tokenByIndex.length++
  tokenByIndex[tokenByIndex.length] = stor13
  if addr(cd[4]):
      if addr(cd[4]):
          if not addr(cd[4]):
              revert with 0, 'ERC721: balance query for the zero address'
          tokenOfOwnerByIndex[addr(cd[4])][stor5[addr(cd[4])]] = stor13
          stor9[stor13] = balanceOf[addr(cd[4])]
  else:
      if tokenByIndex.length - 1 > tokenByIndex.length:
          revert with 0, 17
      if tokenByIndex.length - 1 >= tokenByIndex.length:
          revert with 0, 50
      if stor11[stor13] >= tokenByIndex.length:
          revert with 0, 50
      tokenByIndex[stor11[stor13]] = tokenByIndex[tokenByIndex.length]
      stor11[stor10[stor10.length]] = stor11[stor13]
      stor11[stor13] = 0
      if not tokenByIndex.length:
          revert with 0, 49
      tokenByIndex[tokenByIndex.length] = 0
      tokenByIndex.length--
  if paused:
      revert with 0, 'ERC721Pausable: token transfer while paused'
  if balanceOf[addr(cd[4])] > balanceOf[addr(cd[4])] + 1:
      revert with 0, 17
  balanceOf[addr(cd[4])]++
  ownerOf[stor13] = addr(cd[4])
  log Transfer(
        address from=0,
        address to=addr(cd[4]),
        uint256 tokens=stor13)
  stor13++

def transferFrom(address _from, address _to, uint256 _value) payable: 
  require calldata.size - 4 >=′ 96
  require _from == _from
  require _to == _to
  if not ownerOf[_value]:
      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: operator query for nonexistent token'
  if not ownerOf[_value]:
      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: owner query for nonexistent token'
  if ownerOf[_value] != caller:
      if not stor7[stor4[_value]][caller]:
          if not ownerOf[_value]:
              revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: approved query for nonexistent token'
          if approved[_value] != caller:
              revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: transfer caller is not owner nor approved'
  if not ownerOf[_value]:
      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: owner query for nonexistent token'
  if ownerOf[_value] != _from:
      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: transfer from incorrect owner'
  if not _to:
      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: transfer to the zero address'
  if not _from:
      stor11[_value] = tokenByIndex.length
      tokenByIndex.length++
      tokenByIndex[tokenByIndex.length] = _value
  else:
      if _from != _to:
          if not _from:
              revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: balance query for the zero address'
          if balanceOf[addr(_from)] - 1 > balanceOf[addr(_from)]:
              revert with 0, 17
          if balanceOf[addr(_from)] - 1 != stor9[_value]:
              tokenOfOwnerByIndex[addr(_from)][stor9[_value]] = tokenOfOwnerByIndex[addr(_from)][stor5[addr(_from)] - 1]
              stor9[stor8[addr(_from)][stor5[addr(_from)] - 1]] = stor9[_value]
          stor9[_value] = 0
          tokenOfOwnerByIndex[addr(_from)][stor5[addr(_from)] - 1] = 0
  if _to:
      if _to != _from:
          if not _to:
              revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: balance query for the zero address'
          tokenOfOwnerByIndex[addr(_to)][stor5[addr(_to)]] = _value
          stor9[_value] = balanceOf[addr(_to)]
  else:
      if tokenByIndex.length - 1 > tokenByIndex.length:
          revert with 0, 17
      if tokenByIndex.length - 1 >= tokenByIndex.length:
          revert with 0, 50
      if stor11[_value] >= tokenByIndex.length:
          revert with 0, 50
      tokenByIndex[stor11[_value]] = tokenByIndex[tokenByIndex.length]
      stor11[stor10[stor10.length]] = stor11[_value]
      stor11[_value] = 0
      if not tokenByIndex.length:
          revert with 0, 49
      tokenByIndex[tokenByIndex.length] = 0
      tokenByIndex.length--
  if paused:
      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721Pausable: token transfer while paused'
  approved[_value] = 0
  if not ownerOf[_value]:
      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: owner query for nonexistent token'
  log Approval(
        address tokenOwner=ownerOf[_value],
        address spender=0,
        uint256 tokens=_value)
  if balanceOf[addr(_from)] - 1 > balanceOf[addr(_from)]:
      revert with 0, 17
  balanceOf[addr(_from)]--
  if balanceOf[addr(_to)] > balanceOf[addr(_to)] + 1:
      revert with 0, 17
  balanceOf[addr(_to)]++
  ownerOf[_value] = _to
  log Transfer(
        address from=_from,
        address to=_to,
        uint256 tokens=_value)

def safeTransferFrom(address _from, address _to, uint256 _tokenId) payable: 
  require calldata.size - 4 >=′ 96
  require _from == _from
  require _to == _to
  if not ownerOf[_tokenId]:
      revert with 0, 'ERC721: operator query for nonexistent token'
  if not ownerOf[_tokenId]:
      revert with 0, 'ERC721: owner query for nonexistent token'
  if ownerOf[_tokenId] != caller:
      if not stor7[stor4[_tokenId]][caller]:
          if not ownerOf[_tokenId]:
              revert with 0, 'ERC721: approved query for nonexistent token'
          if approved[_tokenId] != caller:
              revert with 0, 'ERC721: transfer caller is not owner nor approved'
  if not ownerOf[_tokenId]:
      revert with 0, 'ERC721: owner query for nonexistent token'
  if ownerOf[_tokenId] != _from:
      revert with 0, 'ERC721: transfer from incorrect owner'
  if not _to:
      revert with 0, 'ERC721: transfer to the zero address'
  if not _from:
      stor11[_tokenId] = tokenByIndex.length
      tokenByIndex.length++
      tokenByIndex[tokenByIndex.length] = _tokenId
  else:
      if _from != _to:
          if not _from:
              revert with 0, 'ERC721: balance query for the zero address'
          if balanceOf[addr(_from)] - 1 > balanceOf[addr(_from)]:
              revert with 0, 17
          if balanceOf[addr(_from)] - 1 != stor9[_tokenId]:
              tokenOfOwnerByIndex[addr(_from)][stor9[_tokenId]] = tokenOfOwnerByIndex[addr(_from)][stor5[addr(_from)] - 1]
              stor9[stor8[addr(_from)][stor5[addr(_from)] - 1]] = stor9[_tokenId]
          stor9[_tokenId] = 0
          tokenOfOwnerByIndex[addr(_from)][stor5[addr(_from)] - 1] = 0
  if _to:
      if _to != _from:
          if not _to:
              revert with 0, 'ERC721: balance query for the zero address'
          tokenOfOwnerByIndex[addr(_to)][stor5[addr(_to)]] = _tokenId
          stor9[_tokenId] = balanceOf[addr(_to)]
  else:
      if tokenByIndex.length - 1 > tokenByIndex.length:
          revert with 0, 17
      if tokenByIndex.length - 1 >= tokenByIndex.length:
          revert with 0, 50
      if stor11[_tokenId] >= tokenByIndex.length:
          revert with 0, 50
      tokenByIndex[stor11[_tokenId]] = tokenByIndex[tokenByIndex.length]
      stor11[stor10[stor10.length]] = stor11[_tokenId]
      stor11[_tokenId] = 0
      if not tokenByIndex.length:
          revert with 0, 49
      tokenByIndex[tokenByIndex.length] = 0
      tokenByIndex.length--
  if paused:
      revert with 0, 'ERC721Pausable: token transfer while paused'
  approved[_tokenId] = 0
  if not ownerOf[_tokenId]:
      revert with 0, 'ERC721: owner query for nonexistent token'
  log Approval(
        address tokenOwner=ownerOf[_tokenId],
        address spender=0,
        uint256 tokens=_tokenId)
  if balanceOf[addr(_from)] - 1 > balanceOf[addr(_from)]:
      revert with 0, 17
  balanceOf[addr(_from)]--
  if balanceOf[addr(_to)] > balanceOf[addr(_to)] + 1:
      revert with 0, 17
  balanceOf[addr(_to)]++
  ownerOf[_tokenId] = _to
  log Transfer(
        address from=_from,
        address to=_to,
        uint256 tokens=_tokenId)
  if ext_code.size(_to):
      call _to.onERC721Received(address operator, address from, uint256 childTokenId, bytes data) with:
           gas gas_remaining wei
          args 0, uint32(caller), addr(_from), _tokenId, 128, 0
      if not ext_call.success:
          if not return_data.size:
              revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
          if not -return_data.size:
              revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
          revert with ext_call.return_data[0 len return_data.size]
      require return_data.size >=′ 32
      require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
      if Mask(32, 224, ext_call.return_data[0]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
          revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'

def name() payable: 
  if bool(stor2.length):
      if not bool(stor2.length) - (uint255(stor2.length) * 0.5 < 32):
          revert with 0, 34
      if bool(stor2.length):
          if not bool(stor2.length) - (uint255(stor2.length) * 0.5 < 32):
              revert with 0, 34
          if Mask(256, -1, stor2.length):
              if 31 < uint255(stor2.length) * 0.5:
                  mem[128] = uint256(stor2.field_0)
                  idx = 128
                  s = 0
                  while (uint255(stor2.length) * 0.5) + 96 > idx:
                      mem[idx + 32] = stor2[s].field_256
                      idx = idx + 32
                      s = s + 1
                      continue 
                  return Array(len=2 * Mask(256, -1, stor2.length), data=mem[128 len ceil32(uint255(stor2.length) * 0.5)])
              mem[128] = 256 * stor2.length.field_8
      else:
          if not bool(stor2.length) - (stor2.length.field_1 < 32):
              revert with 0, 34
          if stor2.length.field_1:
              if 31 < stor2.length.field_1:
                  mem[128] = uint256(stor2.field_0)
                  idx = 128
                  s = 0
                  while stor2.length.field_1 + 96 > idx:
                      mem[idx + 32] = stor2[s].field_256
                      idx = idx + 32
                      s = s + 1
                      continue 
                  return Array(len=2 * Mask(256, -1, stor2.length), data=mem[128 len ceil32(uint255(stor2.length) * 0.5)])
              mem[128] = 256 * stor2.length.field_8
      mem[ceil32(uint255(stor2.length) * 0.5) + 192 len ceil32(uint255(stor2.length) * 0.5)] = mem[128 len ceil32(uint255(stor2.length) * 0.5)]
      mem[(uint255(stor2.length) * 0.5) + ceil32(uint255(stor2.length) * 0.5) + 192] = 0
      return Array(len=2 * Mask(256, -1, stor2.length), data=mem[128 len ceil32(uint255(stor2.length) * 0.5)], mem[(2 * ceil32(uint255(stor2.length) * 0.5)) + 192 len 2 * ceil32(uint255(stor2.length) * 0.5)]), 
  if not bool(stor2.length) - (stor2.length.field_1 < 32):
      revert with 0, 34
  if bool(stor2.length):
      if not bool(stor2.length) - (uint255(stor2.length) * 0.5 < 32):
          revert with 0, 34
      if Mask(256, -1, stor2.length):
          if 31 < uint255(stor2.length) * 0.5:
              mem[128] = uint256(stor2.field_0)
              idx = 128
              s = 0
              while (uint255(stor2.length) * 0.5) + 96 > idx:
                  mem[idx + 32] = stor2[s].field_256
                  idx = idx + 32
                  s = s + 1
                  continue 
              return Array(len=stor2.length % 128, data=mem[128 len ceil32(stor2.length.field_1)])
          mem[128] = 256 * stor2.length.field_8
  else:
      if not bool(stor2.length) - (stor2.length.field_1 < 32):
          revert with 0, 34
      if stor2.length.field_1:
          if 31 < stor2.length.field_1:
              mem[128] = uint256(stor2.field_0)
              idx = 128
              s = 0
              while stor2.length.field_1 + 96 > idx:
                  mem[idx + 32] = stor2[s].field_256
                  idx = idx + 32
                  s = s + 1
                  continue 
              return Array(len=stor2.length % 128, data=mem[128 len ceil32(stor2.length.field_1)])
          mem[128] = 256 * stor2.length.field_8
  mem[ceil32(stor2.length.field_1) + 192 len ceil32(stor2.length.field_1)] = mem[128 len ceil32(stor2.length.field_1)]
  mem[stor2.length.field_1 + ceil32(stor2.length.field_1) + 192] = 0
  return Array(len=stor2.length % 128, data=mem[128 len ceil32(stor2.length.field_1)], mem[(2 * ceil32(stor2.length.field_1)) + 192 len 2 * ceil32(stor2.length.field_1)]), 

def symbol() payable: 
  if bool(stor3.length):
      if not bool(stor3.length) - (uint255(stor3.length) * 0.5 < 32):
          revert with 0, 34
      if bool(stor3.length):
          if not bool(stor3.length) - (uint255(stor3.length) * 0.5 < 32):
              revert with 0, 34
          if Mask(256, -1, stor3.length):
              if 31 < uint255(stor3.length) * 0.5:
                  mem[128] = uint256(stor3.field_0)
                  idx = 128
                  s = 0
                  while (uint255(stor3.length) * 0.5) + 96 > idx:
                      mem[idx + 32] = stor3[s].field_256
                      idx = idx + 32
                      s = s + 1
                      continue 
                  return Array(len=2 * Mask(256, -1, stor3.length), data=mem[128 len ceil32(uint255(stor3.length) * 0.5)])
              mem[128] = 256 * stor3.length.field_8
      else:
          if not bool(stor3.length) - (stor3.length.field_1 < 32):
              revert with 0, 34
          if stor3.length.field_1:
              if 31 < stor3.length.field_1:
                  mem[128] = uint256(stor3.field_0)
                  idx = 128
                  s = 0
                  while stor3.length.field_1 + 96 > idx:
                      mem[idx + 32] = stor3[s].field_256
                      idx = idx + 32
                      s = s + 1
                      continue 
                  return Array(len=2 * Mask(256, -1, stor3.length), data=mem[128 len ceil32(uint255(stor3.length) * 0.5)])
              mem[128] = 256 * stor3.length.field_8
      mem[ceil32(uint255(stor3.length) * 0.5) + 192 len ceil32(uint255(stor3.length) * 0.5)] = mem[128 len ceil32(uint255(stor3.length) * 0.5)]
      mem[(uint255(stor3.length) * 0.5) + ceil32(uint255(stor3.length) * 0.5) + 192] = 0
      return Array(len=2 * Mask(256, -1, stor3.length), data=mem[128 len ceil32(uint255(stor3.length) * 0.5)], mem[(2 * ceil32(uint255(stor3.length) * 0.5)) + 192 len 2 * ceil32(uint255(stor3.length) * 0.5)]), 
  if not bool(stor3.length) - (stor3.length.field_1 < 32):
      revert with 0, 34
  if bool(stor3.length):
      if not bool(stor3.length) - (uint255(stor3.length) * 0.5 < 32):
          revert with 0, 34
      if Mask(256, -1, stor3.length):
          if 31 < uint255(stor3.length) * 0.5:
              mem[128] = uint256(stor3.field_0)
              idx = 128
              s = 0
              while (uint255(stor3.length) * 0.5) + 96 > idx:
                  mem[idx + 32] = stor3[s].field_256
                  idx = idx + 32
                  s = s + 1
                  continue 
              return Array(len=stor3.length % 128, data=mem[128 len ceil32(stor3.length.field_1)])
          mem[128] = 256 * stor3.length.field_8
  else:
      if not bool(stor3.length) - (stor3.length.field_1 < 32):
          revert with 0, 34
      if stor3.length.field_1:
          if 31 < stor3.length.field_1:
              mem[128] = uint256(stor3.field_0)
              idx = 128
              s = 0
              while stor3.length.field_1 + 96 > idx:
                  mem[idx + 32] = stor3[s].field_256
                  idx = idx + 32
                  s = s + 1
                  continue 
              return Array(len=stor3.length % 128, data=mem[128 len ceil32(stor3.length.field_1)])
          mem[128] = 256 * stor3.length.field_8
  mem[ceil32(stor3.length.field_1) + 192 len ceil32(stor3.length.field_1)] = mem[128 len ceil32(stor3.length.field_1)]
  mem[stor3.length.field_1 + ceil32(stor3.length.field_1) + 192] = 0
  return Array(len=stor3.length % 128, data=mem[128 len ceil32(stor3.length.field_1)], mem[(2 * ceil32(stor3.length.field_1)) + 192 len 2 * ceil32(stor3.length.field_1)]), 

def safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes _data) payable: 
  require calldata.size - 4 >=′ 128
  require _from == _from
  require _to == _to
  require _data <= 18446744073709551615
  require _data + 35 <′ calldata.size
  if _data.length > 18446744073709551615:
      revert with 0, 65
  if ceil32(ceil32(_data.length)) + 97 < 96 or ceil32(ceil32(_data.length)) + 97 > 18446744073709551615:
      revert with 0, 65
  require _data + _data.length + 36 <= calldata.size
  if not ownerOf[_tokenId]:
      revert with 0, 'ERC721: operator query for nonexistent token'
  if not ownerOf[_tokenId]:
      revert with 0, 'ERC721: owner query for nonexistent token'
  if ownerOf[_tokenId] != caller:
      if not stor7[stor4[_tokenId]][caller]:
          if not ownerOf[_tokenId]:
              revert with 0, 'ERC721: approved query for nonexistent token'
          if approved[_tokenId] != caller:
              revert with 0, 'ERC721: transfer caller is not owner nor approved'
  if not ownerOf[_tokenId]:
      revert with 0, 'ERC721: owner query for nonexistent token'
  if ownerOf[_tokenId] != _from:
      revert with 0, 'ERC721: transfer from incorrect owner'
  if not _to:
      revert with 0, 'ERC721: transfer to the zero address'
  if not _from:
      stor11[_tokenId] = tokenByIndex.length
      tokenByIndex.length++
      tokenByIndex[tokenByIndex.length] = _tokenId
  else:
      if _from != _to:
          if not _from:
              revert with 0, 'ERC721: balance query for the zero address'
          if balanceOf[addr(_from)] - 1 > balanceOf[addr(_from)]:
              revert with 0, 17
          if balanceOf[addr(_from)] - 1 != stor9[_tokenId]:
              tokenOfOwnerByIndex[addr(_from)][stor9[_tokenId]] = tokenOfOwnerByIndex[addr(_from)][stor5[addr(_from)] - 1]
              stor9[stor8[addr(_from)][stor5[addr(_from)] - 1]] = stor9[_tokenId]
          stor9[_tokenId] = 0
          tokenOfOwnerByIndex[addr(_from)][stor5[addr(_from)] - 1] = 0
  if _to:
      if _to != _from:
          if not _to:
              revert with 0, 'ERC721: balance query for the zero address'
          tokenOfOwnerByIndex[addr(_to)][stor5[addr(_to)]] = _tokenId
          stor9[_tokenId] = balanceOf[addr(_to)]
  else:
      if tokenByIndex.length - 1 > tokenByIndex.length:
          revert with 0, 17
      if tokenByIndex.length - 1 >= tokenByIndex.length:
          revert with 0, 50
      if stor11[_tokenId] >= tokenByIndex.length:
          revert with 0, 50
      tokenByIndex[stor11[_tokenId]] = tokenByIndex[tokenByIndex.length]
      stor11[stor10[stor10.length]] = stor11[_tokenId]
      stor11[_tokenId] = 0
      if not tokenByIndex.length:
          revert with 0, 49
      tokenByIndex[tokenByIndex.length] = 0
      tokenByIndex.length--
  if paused:
      revert with 0, 'ERC721Pausable: token transfer while paused'
  approved[_tokenId] = 0
  if not ownerOf[_tokenId]:
      revert with 0, 'ERC721: owner query for nonexistent token'
  log Approval(
        address tokenOwner=ownerOf[_tokenId],
        address spender=0,
        uint256 tokens=_tokenId)
  if balanceOf[addr(_from)] - 1 > balanceOf[addr(_from)]:
      revert with 0, 17
  balanceOf[addr(_from)]--
  if balanceOf[addr(_to)] > balanceOf[addr(_to)] + 1:
      revert with 0, 17
  balanceOf[addr(_to)]++
  ownerOf[_tokenId] = _to
  log Transfer(
        address from=_from,
        address to=_to,
        uint256 tokens=_tokenId)
  if ext_code.size(_to):
      call _to.onERC721Received(address operator, address from, uint256 childTokenId, bytes data) with:
           gas gas_remaining wei
          args caller, addr(_from), _tokenId, Array(len=_data.length, data=_data[all])
      if not ext_call.success:
          if not return_data.size:
              if not -_data.length:
                  revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
              revert with _data[all]
          if not -return_data.size:
              revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
          revert with ext_call.return_data[0 len return_data.size]
      require return_data.size >=′ 32
      require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
      if Mask(32, 224, ext_call.return_data[0]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
          revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'

def tokenURI(uint256 _tokenId) payable: 
  require calldata.size - 4 >=′ 32
  mem[0] = _tokenId
  mem[32] = 4
  if not ownerOf[_tokenId]:
      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721Metadata: URI query for nonexistent token'
  if bool(stor14.length):
      if not bool(stor14.length) - (uint255(stor14.length) * 0.5 < 32):
          revert with 0, 34
      mem[96] = uint255(stor14.length) * 0.5
      if bool(stor14.length):
          if not bool(stor14.length) - (uint255(stor14.length) * 0.5 < 32):
              revert with 0, 34
          if not Mask(256, -1, stor14.length):
              if uint255(stor14.length) * 0.5 <= 0:
                  return ''
              if not -_tokenId:
                  mem[ceil32(uint255(stor14.length) * 0.5) + 224 len ceil32(uint255(stor14.length) * 0.5)] = mem[128 len ceil32(uint255(stor14.length) * 0.5)]
                  mem[ceil32(uint255(stor14.length) * 0.5) + (uint255(stor14.length) * 0.5) + 224] = 0x3000000000000000000000000000000000000000000000000000000000000000
                  mem[ceil32(uint255(stor14.length) * 0.5) + (uint255(stor14.length) * 0.5) + 225] = 32
                  mem[ceil32(uint255(stor14.length) * 0.5) + (uint255(stor14.length) * 0.5) + 257] = mem[ceil32(uint255(stor14.length) * 0.5) + 192]
                  mem[ceil32(uint255(stor14.length) * 0.5) + (uint255(stor14.length) * 0.5) + 289 len ceil32(mem[ceil32(uint255(stor14.length) * 0.5) + 192])] = mem[ceil32(uint255(stor14.length) * 0.5) + 224 len ceil32(mem[ceil32(uint255(stor14.length) * 0.5) + 192])]
                  mem[mem[ceil32(uint255(stor14.length) * 0.5) + 192] + ceil32(uint255(stor14.length) * 0.5) + (uint255(stor14.length) * 0.5) + 289] = 0
                  return Array(len=mem[ceil32(uint255(stor14.length) * 0.5) + 192], data=mem[ceil32(uint255(stor14.length) * 0.5) + (uint255(stor14.length) * 0.5) + 289 len ceil32(mem[ceil32(uint255(stor14.length) * 0.5) + 192])]), 
              s = 0
              idx = _tokenId
              while idx:
                  if not s + 1:
                      revert with 0, 17
                  s = s + 1
                  idx = idx / 10
                  continue 
              if s > 18446744073709551615:
                  revert with 0, 65
              mem[ceil32(uint255(stor14.length) * 0.5) + 128] = s
              if not s:
                  t = s
                  idx = _tokenId
                  while idx:
                      if t - 1 > t:
                          revert with 0, 17
                      if 48 > (idx % 10) + 48:
                          revert with 0, 17
                      if t - 1 >= mem[ceil32(uint255(stor14.length) * 0.5) + 128]:
                          revert with 0, 50
                      mem[t + ceil32(uint255(stor14.length) * 0.5) + 159 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                      t = t - 1
                      idx = idx / 10
                      continue 
                  mem[ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + 192 len ceil32(uint255(stor14.length) * 0.5)] = mem[128 len ceil32(uint255(stor14.length) * 0.5)]
                  mem[(uint255(stor14.length) * 0.5) + ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + 192] = 0
                  mem[ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + (uint255(stor14.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(stor14.length) * 0.5) + 128])] = mem[ceil32(uint255(stor14.length) * 0.5) + 160 len ceil32(mem[ceil32(uint255(stor14.length) * 0.5) + 128])]
                  mem[64] = mem[ceil32(uint255(stor14.length) * 0.5) + 128] + ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + (uint255(stor14.length) * 0.5) + 192
                  mem[mem[ceil32(uint255(stor14.length) * 0.5) + 128] + ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + (uint255(stor14.length) * 0.5) + 192] = 32
                  _1414 = mem[ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + 160]
                  mem[mem[ceil32(uint255(stor14.length) * 0.5) + 128] + ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + (uint255(stor14.length) * 0.5) + 224] = mem[ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + 160]
                  mem[mem[ceil32(uint255(stor14.length) * 0.5) + 128] + ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + (uint255(stor14.length) * 0.5) + 256 len ceil32(_1414)] = mem[ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + 192 len ceil32(_1414)]
                  mem[_1414 + mem[ceil32(uint255(stor14.length) * 0.5) + 128] + ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + (uint255(stor14.length) * 0.5) + 256] = 0
                  return 32, mem[mem[ceil32(uint255(stor14.length) * 0.5) + 128] + ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + (uint255(stor14.length) * 0.5) + 224 len ceil32(_1414) + 32], 
              mem[ceil32(uint255(stor14.length) * 0.5) + 160 len s] = call.data[calldata.size len s]
              t = s
              idx = _tokenId
              while idx:
                  if t - 1 > t:
                      revert with 0, 17
                  if 48 > (idx % 10) + 48:
                      revert with 0, 17
                  if t - 1 >= mem[ceil32(uint255(stor14.length) * 0.5) + 128]:
                      revert with 0, 50
                  mem[t + ceil32(uint255(stor14.length) * 0.5) + 159 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                  t = t - 1
                  idx = idx / 10
                  continue 
              mem[ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + 192 len ceil32(uint255(stor14.length) * 0.5)] = mem[128 len ceil32(uint255(stor14.length) * 0.5)]
              mem[(uint255(stor14.length) * 0.5) + ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + 192] = 0
              mem[ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + (uint255(stor14.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(stor14.length) * 0.5) + 128])] = mem[ceil32(uint255(stor14.length) * 0.5) + 160 len ceil32(mem[ceil32(uint255(stor14.length) * 0.5) + 128])]
              mem[64] = mem[ceil32(uint255(stor14.length) * 0.5) + 128] + ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + (uint255(stor14.length) * 0.5) + 192
              mem[mem[ceil32(uint255(stor14.length) * 0.5) + 128] + ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + (uint255(stor14.length) * 0.5) + 192] = 32
              _1415 = mem[ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + 160]
              mem[mem[ceil32(uint255(stor14.length) * 0.5) + 128] + ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + (uint255(stor14.length) * 0.5) + 224] = mem[ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + 160]
              mem[mem[ceil32(uint255(stor14.length) * 0.5) + 128] + ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + (uint255(stor14.length) * 0.5) + 256 len ceil32(_1415)] = mem[ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + 192 len ceil32(_1415)]
              mem[_1415 + mem[ceil32(uint255(stor14.length) * 0.5) + 128] + ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + (uint255(stor14.length) * 0.5) + 256] = 0
              return 32, mem[mem[ceil32(uint255(stor14.length) * 0.5) + 128] + ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + (uint255(stor14.length) * 0.5) + 224 len ceil32(_1415) + 32], 
          if 31 >= uint255(stor14.length) * 0.5:
              mem[128] = 256 * stor14.length.field_8
              if uint255(stor14.length) * 0.5 <= 0:
                  return ''
              if not -_tokenId:
                  mem[ceil32(uint255(stor14.length) * 0.5) + 224 len ceil32(uint255(stor14.length) * 0.5)] = mem[128 len ceil32(uint255(stor14.length) * 0.5)]
                  mem[ceil32(uint255(stor14.length) * 0.5) + (uint255(stor14.length) * 0.5) + 224] = 0x3000000000000000000000000000000000000000000000000000000000000000
                  mem[ceil32(uint255(stor14.length) * 0.5) + (uint255(stor14.length) * 0.5) + 225] = 32
                  mem[ceil32(uint255(stor14.length) * 0.5) + (uint255(stor14.length) * 0.5) + 257] = mem[ceil32(uint255(stor14.length) * 0.5) + 192]
                  mem[ceil32(uint255(stor14.length) * 0.5) + (uint255(stor14.length) * 0.5) + 289 len ceil32(mem[ceil32(uint255(stor14.length) * 0.5) + 192])] = mem[ceil32(uint255(stor14.length) * 0.5) + 224 len ceil32(mem[ceil32(uint255(stor14.length) * 0.5) + 192])]
                  mem[mem[ceil32(uint255(stor14.length) * 0.5) + 192] + ceil32(uint255(stor14.length) * 0.5) + (uint255(stor14.length) * 0.5) + 289] = 0
                  return Array(len=mem[ceil32(uint255(stor14.length) * 0.5) + 192], data=mem[ceil32(uint255(stor14.length) * 0.5) + (uint255(stor14.length) * 0.5) + 289 len ceil32(mem[ceil32(uint255(stor14.length) * 0.5) + 192])]), 
              s = 0
              idx = _tokenId
              while idx:
                  if not s + 1:
                      revert with 0, 17
                  s = s + 1
                  idx = idx / 10
                  continue 
              if s > 18446744073709551615:
                  revert with 0, 65
              mem[ceil32(uint255(stor14.length) * 0.5) + 128] = s
              if not s:
                  t = s
                  idx = _tokenId
                  while idx:
                      if t - 1 > t:
                          revert with 0, 17
                      if 48 > (idx % 10) + 48:
                          revert with 0, 17
                      if t - 1 >= mem[ceil32(uint255(stor14.length) * 0.5) + 128]:
                          revert with 0, 50
                      mem[t + ceil32(uint255(stor14.length) * 0.5) + 159 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                      t = t - 1
                      idx = idx / 10
                      continue 
                  mem[ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + 192 len ceil32(uint255(stor14.length) * 0.5)] = mem[128 len ceil32(uint255(stor14.length) * 0.5)]
                  mem[(uint255(stor14.length) * 0.5) + ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + 192] = 0
                  mem[ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + (uint255(stor14.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(stor14.length) * 0.5) + 128])] = mem[ceil32(uint255(stor14.length) * 0.5) + 160 len ceil32(mem[ceil32(uint255(stor14.length) * 0.5) + 128])]
                  mem[64] = mem[ceil32(uint255(stor14.length) * 0.5) + 128] + ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + (uint255(stor14.length) * 0.5) + 192
                  mem[mem[ceil32(uint255(stor14.length) * 0.5) + 128] + ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + (uint255(stor14.length) * 0.5) + 192] = 32
                  _1416 = mem[ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + 160]
                  mem[mem[ceil32(uint255(stor14.length) * 0.5) + 128] + ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + (uint255(stor14.length) * 0.5) + 224] = mem[ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + 160]
                  mem[mem[ceil32(uint255(stor14.length) * 0.5) + 128] + ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + (uint255(stor14.length) * 0.5) + 256 len ceil32(_1416)] = mem[ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + 192 len ceil32(_1416)]
                  mem[_1416 + mem[ceil32(uint255(stor14.length) * 0.5) + 128] + ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + (uint255(stor14.length) * 0.5) + 256] = 0
                  return 32, mem[mem[ceil32(uint255(stor14.length) * 0.5) + 128] + ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + (uint255(stor14.length) * 0.5) + 224 len ceil32(_1416) + 32], 
              mem[ceil32(uint255(stor14.length) * 0.5) + 160 len s] = call.data[calldata.size len s]
              t = s
              idx = _tokenId
              while idx:
                  if t - 1 > t:
                      revert with 0, 17
                  if 48 > (idx % 10) + 48:
                      revert with 0, 17
                  if t - 1 >= mem[ceil32(uint255(stor14.length) * 0.5) + 128]:
                      revert with 0, 50
                  mem[t + ceil32(uint255(stor14.length) * 0.5) + 159 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                  t = t - 1
                  idx = idx / 10
                  continue 
              mem[ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + 192 len ceil32(uint255(stor14.length) * 0.5)] = mem[128 len ceil32(uint255(stor14.length) * 0.5)]
              mem[(uint255(stor14.length) * 0.5) + ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + 192] = 0
              mem[ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + (uint255(stor14.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(stor14.length) * 0.5) + 128])] = mem[ceil32(uint255(stor14.length) * 0.5) + 160 len ceil32(mem[ceil32(uint255(stor14.length) * 0.5) + 128])]
              mem[64] = mem[ceil32(uint255(stor14.length) * 0.5) + 128] + ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + (uint255(stor14.length) * 0.5) + 192
              mem[mem[ceil32(uint255(stor14.length) * 0.5) + 128] + ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + (uint255(stor14.length) * 0.5) + 192] = 32
              _1417 = mem[ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + 160]
              mem[mem[ceil32(uint255(stor14.length) * 0.5) + 128] + ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + (uint255(stor14.length) * 0.5) + 224] = mem[ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + 160]
              mem[mem[ceil32(uint255(stor14.length) * 0.5) + 128] + ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + (uint255(stor14.length) * 0.5) + 256 len ceil32(_1417)] = mem[ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + 192 len ceil32(_1417)]
              mem[_1417 + mem[ceil32(uint255(stor14.length) * 0.5) + 128] + ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + (uint255(stor14.length) * 0.5) + 256] = 0
              return 32, mem[mem[ceil32(uint255(stor14.length) * 0.5) + 128] + ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + (uint255(stor14.length) * 0.5) + 224 len ceil32(_1417) + 32], 
          mem[0] = 14
          mem[128] = uint256(stor14.field_0)
          idx = 128
          s = 0
          while (uint255(stor14.length) * 0.5) + 96 > idx:
              mem[idx + 32] = stor14[s].field_256
              idx = idx + 32
              s = s + 1
              continue 
          if uint255(stor14.length) * 0.5 <= 0:
              return ''
          if not -_tokenId:
              mem[ceil32(uint255(stor14.length) * 0.5) + 224 len ceil32(uint255(stor14.length) * 0.5)] = mem[128 len ceil32(uint255(stor14.length) * 0.5)]
              mem[ceil32(uint255(stor14.length) * 0.5) + (uint255(stor14.length) * 0.5) + 224] = 0x3000000000000000000000000000000000000000000000000000000000000000
              mem[ceil32(uint255(stor14.length) * 0.5) + (uint255(stor14.length) * 0.5) + 225] = 32
              mem[ceil32(uint255(stor14.length) * 0.5) + (uint255(stor14.length) * 0.5) + 257] = mem[ceil32(uint255(stor14.length) * 0.5) + 192]
              mem[ceil32(uint255(stor14.length) * 0.5) + (uint255(stor14.length) * 0.5) + 289 len ceil32(mem[ceil32(uint255(stor14.length) * 0.5) + 192])] = mem[ceil32(uint255(stor14.length) * 0.5) + 224 len ceil32(mem[ceil32(uint255(stor14.length) * 0.5) + 192])]
              mem[mem[ceil32(uint255(stor14.length) * 0.5) + 192] + ceil32(uint255(stor14.length) * 0.5) + (uint255(stor14.length) * 0.5) + 289] = 0
              return Array(len=mem[ceil32(uint255(stor14.length) * 0.5) + 192], data=mem[ceil32(uint255(stor14.length) * 0.5) + (uint255(stor14.length) * 0.5) + 289 len ceil32(mem[ceil32(uint255(stor14.length) * 0.5) + 192])]), 
          s = 0
          idx = _tokenId
          while idx:
              if not s + 1:
                  revert with 0, 17
              s = s + 1
              idx = idx / 10
              continue 
          if s > 18446744073709551615:
              revert with 0, 65
          mem[ceil32(uint255(stor14.length) * 0.5) + 128] = s
          if not s:
              t = s
              idx = _tokenId
              while idx:
                  if t - 1 > t:
                      revert with 0, 17
                  if 48 > (idx % 10) + 48:
                      revert with 0, 17
                  if t - 1 >= mem[ceil32(uint255(stor14.length) * 0.5) + 128]:
                      revert with 0, 50
                  mem[t + ceil32(uint255(stor14.length) * 0.5) + 159 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                  t = t - 1
                  idx = idx / 10
                  continue 
              mem[ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + 192 len ceil32(uint255(stor14.length) * 0.5)] = mem[128 len ceil32(uint255(stor14.length) * 0.5)]
              mem[(uint255(stor14.length) * 0.5) + ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + 192] = 0
              mem[ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + (uint255(stor14.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(stor14.length) * 0.5) + 128])] = mem[ceil32(uint255(stor14.length) * 0.5) + 160 len ceil32(mem[ceil32(uint255(stor14.length) * 0.5) + 128])]
              mem[64] = mem[ceil32(uint255(stor14.length) * 0.5) + 128] + ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + (uint255(stor14.length) * 0.5) + 192
              mem[mem[ceil32(uint255(stor14.length) * 0.5) + 128] + ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + (uint255(stor14.length) * 0.5) + 192] = 32
              _1558 = mem[ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + 160]
              mem[mem[ceil32(uint255(stor14.length) * 0.5) + 128] + ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + (uint255(stor14.length) * 0.5) + 224] = mem[ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + 160]
              mem[mem[ceil32(uint255(stor14.length) * 0.5) + 128] + ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + (uint255(stor14.length) * 0.5) + 256 len ceil32(_1558)] = mem[ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + 192 len ceil32(_1558)]
              mem[_1558 + mem[ceil32(uint255(stor14.length) * 0.5) + 128] + ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + (uint255(stor14.length) * 0.5) + 256] = 0
              return 32, mem[mem[ceil32(uint255(stor14.length) * 0.5) + 128] + ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + (uint255(stor14.length) * 0.5) + 224 len ceil32(_1558) + 32], 
          mem[ceil32(uint255(stor14.length) * 0.5) + 160 len s] = call.data[calldata.size len s]
          t = s
          idx = _tokenId
          while idx:
              if t - 1 > t:
                  revert with 0, 17
              if 48 > (idx % 10) + 48:
                  revert with 0, 17
              if t - 1 >= mem[ceil32(uint255(stor14.length) * 0.5) + 128]:
                  revert with 0, 50
              mem[t + ceil32(uint255(stor14.length) * 0.5) + 159 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
              t = t - 1
              idx = idx / 10
              continue 
          mem[ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + 192 len ceil32(uint255(stor14.length) * 0.5)] = mem[128 len ceil32(uint255(stor14.length) * 0.5)]
          mem[(uint255(stor14.length) * 0.5) + ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + 192] = 0
          mem[ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + (uint255(stor14.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(stor14.length) * 0.5) + 128])] = mem[ceil32(uint255(stor14.length) * 0.5) + 160 len ceil32(mem[ceil32(uint255(stor14.length) * 0.5) + 128])]
          mem[64] = mem[ceil32(uint255(stor14.length) * 0.5) + 128] + ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + (uint255(stor14.length) * 0.5) + 192
          mem[mem[ceil32(uint255(stor14.length) * 0.5) + 128] + ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + (uint255(stor14.length) * 0.5) + 192] = 32
          _1559 = mem[ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + 160]
          mem[mem[ceil32(uint255(stor14.length) * 0.5) + 128] + ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + (uint255(stor14.length) * 0.5) + 224] = mem[ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + 160]
          mem[mem[ceil32(uint255(stor14.length) * 0.5) + 128] + ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + (uint255(stor14.length) * 0.5) + 256 len ceil32(_1559)] = mem[ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + 192 len ceil32(_1559)]
          mem[_1559 + mem[ceil32(uint255(stor14.length) * 0.5) + 128] + ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + (uint255(stor14.length) * 0.5) + 256] = 0
          return 32, mem[mem[ceil32(uint255(stor14.length) * 0.5) + 128] + ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + (uint255(stor14.length) * 0.5) + 224 len ceil32(_1559) + 32], 
      if not bool(stor14.length) - (stor14.length.field_1 < 32):
          revert with 0, 34
      if not stor14.length.field_1:
          if uint255(stor14.length) * 0.5 <= 0:
              return ''
          if not -_tokenId:
              mem[ceil32(uint255(stor14.length) * 0.5) + 224 len ceil32(uint255(stor14.length) * 0.5)] = mem[128 len ceil32(uint255(stor14.length) * 0.5)]
              mem[ceil32(uint255(stor14.length) * 0.5) + (uint255(stor14.length) * 0.5) + 224] = 0x3000000000000000000000000000000000000000000000000000000000000000
              mem[ceil32(uint255(stor14.length) * 0.5) + (uint255(stor14.length) * 0.5) + 225] = 32
              mem[ceil32(uint255(stor14.length) * 0.5) + (uint255(stor14.length) * 0.5) + 257] = mem[ceil32(uint255(stor14.length) * 0.5) + 192]
              mem[ceil32(uint255(stor14.length) * 0.5) + (uint255(stor14.length) * 0.5) + 289 len ceil32(mem[ceil32(uint255(stor14.length) * 0.5) + 192])] = mem[ceil32(uint255(stor14.length) * 0.5) + 224 len ceil32(mem[ceil32(uint255(stor14.length) * 0.5) + 192])]
              mem[mem[ceil32(uint255(stor14.length) * 0.5) + 192] + ceil32(uint255(stor14.length) * 0.5) + (uint255(stor14.length) * 0.5) + 289] = 0
              return Array(len=mem[ceil32(uint255(stor14.length) * 0.5) + 192], data=mem[ceil32(uint255(stor14.length) * 0.5) + (uint255(stor14.length) * 0.5) + 289 len ceil32(mem[ceil32(uint255(stor14.length) * 0.5) + 192])]), 
          s = 0
          idx = _tokenId
          while idx:
              if not s + 1:
                  revert with 0, 17
              s = s + 1
              idx = idx / 10
              continue 
          if s > 18446744073709551615:
              revert with 0, 65
          mem[ceil32(uint255(stor14.length) * 0.5) + 128] = s
          if not s:
              t = s
              idx = _tokenId
              while idx:
                  if t - 1 > t:
                      revert with 0, 17
                  if 48 > (idx % 10) + 48:
                      revert with 0, 17
                  if t - 1 >= mem[ceil32(uint255(stor14.length) * 0.5) + 128]:
                      revert with 0, 50
                  mem[t + ceil32(uint255(stor14.length) * 0.5) + 159 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                  t = t - 1
                  idx = idx / 10
                  continue 
              mem[ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + 192 len ceil32(uint255(stor14.length) * 0.5)] = mem[128 len ceil32(uint255(stor14.length) * 0.5)]
              mem[(uint255(stor14.length) * 0.5) + ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + 192] = 0
              mem[ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + (uint255(stor14.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(stor14.length) * 0.5) + 128])] = mem[ceil32(uint255(stor14.length) * 0.5) + 160 len ceil32(mem[ceil32(uint255(stor14.length) * 0.5) + 128])]
              mem[64] = mem[ceil32(uint255(stor14.length) * 0.5) + 128] + ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + (uint255(stor14.length) * 0.5) + 192
              mem[mem[ceil32(uint255(stor14.length) * 0.5) + 128] + ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + (uint255(stor14.length) * 0.5) + 192] = 32
              _1418 = mem[ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + 160]
              mem[mem[ceil32(uint255(stor14.length) * 0.5) + 128] + ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + (uint255(stor14.length) * 0.5) + 224] = mem[ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + 160]
              mem[mem[ceil32(uint255(stor14.length) * 0.5) + 128] + ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + (uint255(stor14.length) * 0.5) + 256 len ceil32(_1418)] = mem[ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + 192 len ceil32(_1418)]
              mem[_1418 + mem[ceil32(uint255(stor14.length) * 0.5) + 128] + ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + (uint255(stor14.length) * 0.5) + 256] = 0
              return 32, mem[mem[ceil32(uint255(stor14.length) * 0.5) + 128] + ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + (uint255(stor14.length) * 0.5) + 224 len ceil32(_1418) + 32], 
          mem[ceil32(uint255(stor14.length) * 0.5) + 160 len s] = call.data[calldata.size len s]
          t = s
          idx = _tokenId
          while idx:
              if t - 1 > t:
                  revert with 0, 17
              if 48 > (idx % 10) + 48:
                  revert with 0, 17
              if t - 1 >= mem[ceil32(uint255(stor14.length) * 0.5) + 128]:
                  revert with 0, 50
              mem[t + ceil32(uint255(stor14.length) * 0.5) + 159 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
              t = t - 1
              idx = idx / 10
              continue 
          mem[ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + 192 len ceil32(uint255(stor14.length) * 0.5)] = mem[128 len ceil32(uint255(stor14.length) * 0.5)]
          mem[(uint255(stor14.length) * 0.5) + ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + 192] = 0
          mem[ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + (uint255(stor14.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(stor14.length) * 0.5) + 128])] = mem[ceil32(uint255(stor14.length) * 0.5) + 160 len ceil32(mem[ceil32(uint255(stor14.length) * 0.5) + 128])]
          mem[64] = mem[ceil32(uint255(stor14.length) * 0.5) + 128] + ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + (uint255(stor14.length) * 0.5) + 192
          mem[mem[ceil32(uint255(stor14.length) * 0.5) + 128] + ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + (uint255(stor14.length) * 0.5) + 192] = 32
          _1419 = mem[ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + 160]
          mem[mem[ceil32(uint255(stor14.length) * 0.5) + 128] + ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + (uint255(stor14.length) * 0.5) + 224] = mem[ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + 160]
          mem[mem[ceil32(uint255(stor14.length) * 0.5) + 128] + ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + (uint255(stor14.length) * 0.5) + 256 len ceil32(_1419)] = mem[ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + 192 len ceil32(_1419)]
          mem[_1419 + mem[ceil32(uint255(stor14.length) * 0.5) + 128] + ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + (uint255(stor14.length) * 0.5) + 256] = 0
          return 32, mem[mem[ceil32(uint255(stor14.length) * 0.5) + 128] + ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + (uint255(stor14.length) * 0.5) + 224 len ceil32(_1419) + 32], 
      if 31 >= stor14.length.field_1:
          mem[128] = 256 * stor14.length.field_8
          if uint255(stor14.length) * 0.5 <= 0:
              return ''
          if not -_tokenId:
              mem[ceil32(uint255(stor14.length) * 0.5) + 224 len ceil32(uint255(stor14.length) * 0.5)] = mem[128 len ceil32(uint255(stor14.length) * 0.5)]
              mem[ceil32(uint255(stor14.length) * 0.5) + (uint255(stor14.length) * 0.5) + 224] = 0x3000000000000000000000000000000000000000000000000000000000000000
              mem[ceil32(uint255(stor14.length) * 0.5) + (uint255(stor14.length) * 0.5) + 225] = 32
              mem[ceil32(uint255(stor14.length) * 0.5) + (uint255(stor14.length) * 0.5) + 257] = mem[ceil32(uint255(stor14.length) * 0.5) + 192]
              mem[ceil32(uint255(stor14.length) * 0.5) + (uint255(stor14.length) * 0.5) + 289 len ceil32(mem[ceil32(uint255(stor14.length) * 0.5) + 192])] = mem[ceil32(uint255(stor14.length) * 0.5) + 224 len ceil32(mem[ceil32(uint255(stor14.length) * 0.5) + 192])]
              mem[mem[ceil32(uint255(stor14.length) * 0.5) + 192] + ceil32(uint255(stor14.length) * 0.5) + (uint255(stor14.length) * 0.5) + 289] = 0
              return Array(len=mem[ceil32(uint255(stor14.length) * 0.5) + 192], data=mem[ceil32(uint255(stor14.length) * 0.5) + (uint255(stor14.length) * 0.5) + 289 len ceil32(mem[ceil32(uint255(stor14.length) * 0.5) + 192])]), 
          s = 0
          idx = _tokenId
          while idx:
              if not s + 1:
                  revert with 0, 17
              s = s + 1
              idx = idx / 10
              continue 
          if s > 18446744073709551615:
              revert with 0, 65
          mem[ceil32(uint255(stor14.length) * 0.5) + 128] = s
          if not s:
              t = s
              idx = _tokenId
              while idx:
                  if t - 1 > t:
                      revert with 0, 17
                  if 48 > (idx % 10) + 48:
                      revert with 0, 17
                  if t - 1 >= mem[ceil32(uint255(stor14.length) * 0.5) + 128]:
                      revert with 0, 50
                  mem[t + ceil32(uint255(stor14.length) * 0.5) + 159 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                  t = t - 1
                  idx = idx / 10
                  continue 
              mem[ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + 192 len ceil32(uint255(stor14.length) * 0.5)] = mem[128 len ceil32(uint255(stor14.length) * 0.5)]
              mem[(uint255(stor14.length) * 0.5) + ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + 192] = 0
              mem[ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + (uint255(stor14.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(stor14.length) * 0.5) + 128])] = mem[ceil32(uint255(stor14.length) * 0.5) + 160 len ceil32(mem[ceil32(uint255(stor14.length) * 0.5) + 128])]
              mem[64] = mem[ceil32(uint255(stor14.length) * 0.5) + 128] + ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + (uint255(stor14.length) * 0.5) + 192
              mem[mem[ceil32(uint255(stor14.length) * 0.5) + 128] + ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + (uint255(stor14.length) * 0.5) + 192] = 32
              _1420 = mem[ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + 160]
              mem[mem[ceil32(uint255(stor14.length) * 0.5) + 128] + ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + (uint255(stor14.length) * 0.5) + 224] = mem[ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + 160]
              mem[mem[ceil32(uint255(stor14.length) * 0.5) + 128] + ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + (uint255(stor14.length) * 0.5) + 256 len ceil32(_1420)] = mem[ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + 192 len ceil32(_1420)]
              mem[_1420 + mem[ceil32(uint255(stor14.length) * 0.5) + 128] + ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + (uint255(stor14.length) * 0.5) + 256] = 0
              return 32, mem[mem[ceil32(uint255(stor14.length) * 0.5) + 128] + ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + (uint255(stor14.length) * 0.5) + 224 len ceil32(_1420) + 32], 
          mem[ceil32(uint255(stor14.length) * 0.5) + 160 len s] = call.data[calldata.size len s]
          t = s
          idx = _tokenId
          while idx:
              if t - 1 > t:
                  revert with 0, 17
              if 48 > (idx % 10) + 48:
                  revert with 0, 17
              if t - 1 >= mem[ceil32(uint255(stor14.length) * 0.5) + 128]:
                  revert with 0, 50
              mem[t + ceil32(uint255(stor14.length) * 0.5) + 159 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
              t = t - 1
              idx = idx / 10
              continue 
          mem[ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + 192 len ceil32(uint255(stor14.length) * 0.5)] = mem[128 len ceil32(uint255(stor14.length) * 0.5)]
          mem[(uint255(stor14.length) * 0.5) + ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + 192] = 0
          mem[ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + (uint255(stor14.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(stor14.length) * 0.5) + 128])] = mem[ceil32(uint255(stor14.length) * 0.5) + 160 len ceil32(mem[ceil32(uint255(stor14.length) * 0.5) + 128])]
          mem[64] = mem[ceil32(uint255(stor14.length) * 0.5) + 128] + ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + (uint255(stor14.length) * 0.5) + 192
          mem[mem[ceil32(uint255(stor14.length) * 0.5) + 128] + ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + (uint255(stor14.length) * 0.5) + 192] = 32
          _1421 = mem[ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + 160]
          mem[mem[ceil32(uint255(stor14.length) * 0.5) + 128] + ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + (uint255(stor14.length) * 0.5) + 224] = mem[ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + 160]
          mem[mem[ceil32(uint255(stor14.length) * 0.5) + 128] + ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + (uint255(stor14.length) * 0.5) + 256 len ceil32(_1421)] = mem[ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + 192 len ceil32(_1421)]
          mem[_1421 + mem[ceil32(uint255(stor14.length) * 0.5) + 128] + ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + (uint255(stor14.length) * 0.5) + 256] = 0
          return 32, mem[mem[ceil32(uint255(stor14.length) * 0.5) + 128] + ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + (uint255(stor14.length) * 0.5) + 224 len ceil32(_1421) + 32], 
      mem[0] = 14
      mem[128] = uint256(stor14.field_0)
      idx = 128
      s = 0
      while stor14.length.field_1 + 96 > idx:
          mem[idx + 32] = stor14[s].field_256
          idx = idx + 32
          s = s + 1
          continue 
      if uint255(stor14.length) * 0.5 <= 0:
          return ''
      if not -_tokenId:
          mem[ceil32(uint255(stor14.length) * 0.5) + 224 len ceil32(uint255(stor14.length) * 0.5)] = mem[128 len ceil32(uint255(stor14.length) * 0.5)]
          mem[ceil32(uint255(stor14.length) * 0.5) + (uint255(stor14.length) * 0.5) + 224] = 0x3000000000000000000000000000000000000000000000000000000000000000
          mem[ceil32(uint255(stor14.length) * 0.5) + (uint255(stor14.length) * 0.5) + 225] = 32
          mem[ceil32(uint255(stor14.length) * 0.5) + (uint255(stor14.length) * 0.5) + 257] = mem[ceil32(uint255(stor14.length) * 0.5) + 192]
          mem[ceil32(uint255(stor14.length) * 0.5) + (uint255(stor14.length) * 0.5) + 289 len ceil32(mem[ceil32(uint255(stor14.length) * 0.5) + 192])] = mem[ceil32(uint255(stor14.length) * 0.5) + 224 len ceil32(mem[ceil32(uint255(stor14.length) * 0.5) + 192])]
          mem[mem[ceil32(uint255(stor14.length) * 0.5) + 192] + ceil32(uint255(stor14.length) * 0.5) + (uint255(stor14.length) * 0.5) + 289] = 0
          return Array(len=mem[ceil32(uint255(stor14.length) * 0.5) + 192], data=mem[ceil32(uint255(stor14.length) * 0.5) + (uint255(stor14.length) * 0.5) + 289 len ceil32(mem[ceil32(uint255(stor14.length) * 0.5) + 192])]), 
      s = 0
      idx = _tokenId
      while idx:
          if not s + 1:
              revert with 0, 17
          s = s + 1
          idx = idx / 10
          continue 
      if s > 18446744073709551615:
          revert with 0, 65
      mem[ceil32(uint255(stor14.length) * 0.5) + 128] = s
      if not s:
          t = s
          idx = _tokenId
          while idx:
              if t - 1 > t:
                  revert with 0, 17
              if 48 > (idx % 10) + 48:
                  revert with 0, 17
              if t - 1 >= mem[ceil32(uint255(stor14.length) * 0.5) + 128]:
                  revert with 0, 50
              mem[t + ceil32(uint255(stor14.length) * 0.5) + 159 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
              t = t - 1
              idx = idx / 10
              continue 
          mem[ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + 192 len ceil32(uint255(stor14.length) * 0.5)] = mem[128 len ceil32(uint255(stor14.length) * 0.5)]
          mem[(uint255(stor14.length) * 0.5) + ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + 192] = 0
          mem[ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + (uint255(stor14.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(stor14.length) * 0.5) + 128])] = mem[ceil32(uint255(stor14.length) * 0.5) + 160 len ceil32(mem[ceil32(uint255(stor14.length) * 0.5) + 128])]
          mem[64] = mem[ceil32(uint255(stor14.length) * 0.5) + 128] + ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + (uint255(stor14.length) * 0.5) + 192
          mem[mem[ceil32(uint255(stor14.length) * 0.5) + 128] + ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + (uint255(stor14.length) * 0.5) + 192] = 32
          _1560 = mem[ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + 160]
          mem[mem[ceil32(uint255(stor14.length) * 0.5) + 128] + ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + (uint255(stor14.length) * 0.5) + 224] = mem[ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + 160]
          mem[mem[ceil32(uint255(stor14.length) * 0.5) + 128] + ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + (uint255(stor14.length) * 0.5) + 256 len ceil32(_1560)] = mem[ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + 192 len ceil32(_1560)]
          mem[_1560 + mem[ceil32(uint255(stor14.length) * 0.5) + 128] + ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + (uint255(stor14.length) * 0.5) + 256] = 0
          return 32, mem[mem[ceil32(uint255(stor14.length) * 0.5) + 128] + ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + (uint255(stor14.length) * 0.5) + 224 len ceil32(_1560) + 32], 
      mem[ceil32(uint255(stor14.length) * 0.5) + 160 len s] = call.data[calldata.size len s]
      t = s
      idx = _tokenId
      while idx:
          if t - 1 > t:
              revert with 0, 17
          if 48 > (idx % 10) + 48:
              revert with 0, 17
          if t - 1 >= mem[ceil32(uint255(stor14.length) * 0.5) + 128]:
              revert with 0, 50
          mem[t + ceil32(uint255(stor14.length) * 0.5) + 159 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
          t = t - 1
          idx = idx / 10
          continue 
      mem[ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + 192 len ceil32(uint255(stor14.length) * 0.5)] = mem[128 len ceil32(uint255(stor14.length) * 0.5)]
      mem[(uint255(stor14.length) * 0.5) + ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + 192] = 0
      mem[ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + (uint255(stor14.length) * 0.5) + 192 len ceil32(mem[ceil32(uint255(stor14.length) * 0.5) + 128])] = mem[ceil32(uint255(stor14.length) * 0.5) + 160 len ceil32(mem[ceil32(uint255(stor14.length) * 0.5) + 128])]
      mem[64] = mem[ceil32(uint255(stor14.length) * 0.5) + 128] + ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + (uint255(stor14.length) * 0.5) + 192
      mem[mem[ceil32(uint255(stor14.length) * 0.5) + 128] + ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + (uint255(stor14.length) * 0.5) + 192] = 32
      _1561 = mem[ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + 160]
      mem[mem[ceil32(uint255(stor14.length) * 0.5) + 128] + ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + (uint255(stor14.length) * 0.5) + 224] = mem[ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + 160]
      mem[mem[ceil32(uint255(stor14.length) * 0.5) + 128] + ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + (uint255(stor14.length) * 0.5) + 256 len ceil32(_1561)] = mem[ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + 192 len ceil32(_1561)]
      mem[_1561 + mem[ceil32(uint255(stor14.length) * 0.5) + 128] + ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + (uint255(stor14.length) * 0.5) + 256] = 0
      return 32, mem[mem[ceil32(uint255(stor14.length) * 0.5) + 128] + ceil32(uint255(stor14.length) * 0.5) + ceil32(s) + (uint255(stor14.length) * 0.5) + 224 len ceil32(_1561) + 32], 
  if not bool(stor14.length) - (stor14.length.field_1 < 32):
      revert with 0, 34
  mem[96] = stor14.length.field_1
  if bool(stor14.length):
      if not bool(stor14.length) - (uint255(stor14.length) * 0.5 < 32):
          revert with 0, 34
      if not Mask(256, -1, stor14.length):
          if stor14.length.field_1 <= 0:
              return ''
          if not -_tokenId:
              mem[ceil32(stor14.length.field_1) + 224 len ceil32(stor14.length.field_1)] = mem[128 len ceil32(stor14.length.field_1)]
              mem[ceil32(stor14.length.field_1) + stor14.length.field_1 + 224] = 0x3000000000000000000000000000000000000000000000000000000000000000
              mem[ceil32(stor14.length.field_1) + stor14.length.field_1 + 225] = 32
              mem[ceil32(stor14.length.field_1) + stor14.length.field_1 + 257] = mem[ceil32(stor14.length.field_1) + 192]
              mem[ceil32(stor14.length.field_1) + stor14.length.field_1 + 289 len ceil32(mem[ceil32(stor14.length.field_1) + 192])] = mem[ceil32(stor14.length.field_1) + 224 len ceil32(mem[ceil32(stor14.length.field_1) + 192])]
              mem[mem[ceil32(stor14.length.field_1) + 192] + ceil32(stor14.length.field_1) + stor14.length.field_1 + 289] = 0
              return Array(len=mem[ceil32(stor14.length.field_1) + 192], data=mem[ceil32(stor14.length.field_1) + stor14.length.field_1 + 289 len ceil32(mem[ceil32(stor14.length.field_1) + 192])]), 
          s = 0
          idx = _tokenId
          while idx:
              if not s + 1:
                  revert with 0, 17
              s = s + 1
              idx = idx / 10
              continue 
          if s > 18446744073709551615:
              revert with 0, 65
          mem[ceil32(stor14.length.field_1) + 128] = s
          if not s:
              t = s
              idx = _tokenId
              while idx:
                  if t - 1 > t:
                      revert with 0, 17
                  if 48 > (idx % 10) + 48:
                      revert with 0, 17
                  if t - 1 >= mem[ceil32(stor14.length.field_1) + 128]:
                      revert with 0, 50
                  mem[t + ceil32(stor14.length.field_1) + 159 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                  t = t - 1
                  idx = idx / 10
                  continue 
              mem[ceil32(stor14.length.field_1) + ceil32(s) + 192 len ceil32(stor14.length.field_1)] = mem[128 len ceil32(stor14.length.field_1)]
              mem[stor14.length.field_1 + ceil32(stor14.length.field_1) + ceil32(s) + 192] = 0
              mem[ceil32(stor14.length.field_1) + ceil32(s) + stor14.length.field_1 + 192 len ceil32(mem[ceil32(stor14.length.field_1) + 128])] = mem[ceil32(stor14.length.field_1) + 160 len ceil32(mem[ceil32(stor14.length.field_1) + 128])]
              mem[64] = mem[ceil32(stor14.length.field_1) + 128] + ceil32(stor14.length.field_1) + ceil32(s) + stor14.length.field_1 + 192
              mem[mem[ceil32(stor14.length.field_1) + 128] + ceil32(stor14.length.field_1) + ceil32(s) + stor14.length.field_1 + 192] = 32
              _1422 = mem[ceil32(stor14.length.field_1) + ceil32(s) + 160]
              mem[mem[ceil32(stor14.length.field_1) + 128] + ceil32(stor14.length.field_1) + ceil32(s) + stor14.length.field_1 + 224] = mem[ceil32(stor14.length.field_1) + ceil32(s) + 160]
              mem[mem[ceil32(stor14.length.field_1) + 128] + ceil32(stor14.length.field_1) + ceil32(s) + stor14.length.field_1 + 256 len ceil32(_1422)] = mem[ceil32(stor14.length.field_1) + ceil32(s) + 192 len ceil32(_1422)]
              mem[_1422 + mem[ceil32(stor14.length.field_1) + 128] + ceil32(stor14.length.field_1) + ceil32(s) + stor14.length.field_1 + 256] = 0
              return 32, mem[mem[ceil32(stor14.length.field_1) + 128] + ceil32(stor14.length.field_1) + ceil32(s) + stor14.length.field_1 + 224 len ceil32(_1422) + 32], 
          mem[ceil32(stor14.length.field_1) + 160 len s] = call.data[calldata.size len s]
          t = s
          idx = _tokenId
          while idx:
              if t - 1 > t:
                  revert with 0, 17
              if 48 > (idx % 10) + 48:
                  revert with 0, 17
              if t - 1 >= mem[ceil32(stor14.length.field_1) + 128]:
                  revert with 0, 50
              mem[t + ceil32(stor14.length.field_1) + 159 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
              t = t - 1
              idx = idx / 10
              continue 
          mem[ceil32(stor14.length.field_1) + ceil32(s) + 192 len ceil32(stor14.length.field_1)] = mem[128 len ceil32(stor14.length.field_1)]
          mem[stor14.length.field_1 + ceil32(stor14.length.field_1) + ceil32(s) + 192] = 0
          mem[ceil32(stor14.length.field_1) + ceil32(s) + stor14.length.field_1 + 192 len ceil32(mem[ceil32(stor14.length.field_1) + 128])] = mem[ceil32(stor14.length.field_1) + 160 len ceil32(mem[ceil32(stor14.length.field_1) + 128])]
          mem[64] = mem[ceil32(stor14.length.field_1) + 128] + ceil32(stor14.length.field_1) + ceil32(s) + stor14.length.field_1 + 192
          mem[mem[ceil32(stor14.length.field_1) + 128] + ceil32(stor14.length.field_1) + ceil32(s) + stor14.length.field_1 + 192] = 32
          _1423 = mem[ceil32(stor14.length.field_1) + ceil32(s) + 160]
          mem[mem[ceil32(stor14.length.field_1) + 128] + ceil32(stor14.length.field_1) + ceil32(s) + stor14.length.field_1 + 224] = mem[ceil32(stor14.length.field_1) + ceil32(s) + 160]
          mem[mem[ceil32(stor14.length.field_1) + 128] + ceil32(stor14.length.field_1) + ceil32(s) + stor14.length.field_1 + 256 len ceil32(_1423)] = mem[ceil32(stor14.length.field_1) + ceil32(s) + 192 len ceil32(_1423)]
          mem[_1423 + mem[ceil32(stor14.length.field_1) + 128] + ceil32(stor14.length.field_1) + ceil32(s) + stor14.length.field_1 + 256] = 0
          return 32, mem[mem[ceil32(stor14.length.field_1) + 128] + ceil32(stor14.length.field_1) + ceil32(s) + stor14.length.field_1 + 224 len ceil32(_1423) + 32], 
      if 31 >= uint255(stor14.length) * 0.5:
          mem[128] = 256 * stor14.length.field_8
          if stor14.length.field_1 <= 0:
              return ''
          if not -_tokenId:
              mem[ceil32(stor14.length.field_1) + 224 len ceil32(stor14.length.field_1)] = mem[128 len ceil32(stor14.length.field_1)]
              mem[ceil32(stor14.length.field_1) + stor14.length.field_1 + 224] = 0x3000000000000000000000000000000000000000000000000000000000000000
              mem[ceil32(stor14.length.field_1) + stor14.length.field_1 + 225] = 32
              mem[ceil32(stor14.length.field_1) + stor14.length.field_1 + 257] = mem[ceil32(stor14.length.field_1) + 192]
              mem[ceil32(stor14.length.field_1) + stor14.length.field_1 + 289 len ceil32(mem[ceil32(stor14.length.field_1) + 192])] = mem[ceil32(stor14.length.field_1) + 224 len ceil32(mem[ceil32(stor14.length.field_1) + 192])]
              mem[mem[ceil32(stor14.length.field_1) + 192] + ceil32(stor14.length.field_1) + stor14.length.field_1 + 289] = 0
              return Array(len=mem[ceil32(stor14.length.field_1) + 192], data=mem[ceil32(stor14.length.field_1) + stor14.length.field_1 + 289 len ceil32(mem[ceil32(stor14.length.field_1) + 192])]), 
          s = 0
          idx = _tokenId
          while idx:
              if not s + 1:
                  revert with 0, 17
              s = s + 1
              idx = idx / 10
              continue 
          if s > 18446744073709551615:
              revert with 0, 65
          mem[ceil32(stor14.length.field_1) + 128] = s
          if not s:
              t = s
              idx = _tokenId
              while idx:
                  if t - 1 > t:
                      revert with 0, 17
                  if 48 > (idx % 10) + 48:
                      revert with 0, 17
                  if t - 1 >= mem[ceil32(stor14.length.field_1) + 128]:
                      revert with 0, 50
                  mem[t + ceil32(stor14.length.field_1) + 159 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                  t = t - 1
                  idx = idx / 10
                  continue 
              mem[ceil32(stor14.length.field_1) + ceil32(s) + 192 len ceil32(stor14.length.field_1)] = mem[128 len ceil32(stor14.length.field_1)]
              mem[stor14.length.field_1 + ceil32(stor14.length.field_1) + ceil32(s) + 192] = 0
              mem[ceil32(stor14.length.field_1) + ceil32(s) + stor14.length.field_1 + 192 len ceil32(mem[ceil32(stor14.length.field_1) + 128])] = mem[ceil32(stor14.length.field_1) + 160 len ceil32(mem[ceil32(stor14.length.field_1) + 128])]
              mem[64] = mem[ceil32(stor14.length.field_1) + 128] + ceil32(stor14.length.field_1) + ceil32(s) + stor14.length.field_1 + 192
              mem[mem[ceil32(stor14.length.field_1) + 128] + ceil32(stor14.length.field_1) + ceil32(s) + stor14.length.field_1 + 192] = 32
              _1424 = mem[ceil32(stor14.length.field_1) + ceil32(s) + 160]
              mem[mem[ceil32(stor14.length.field_1) + 128] + ceil32(stor14.length.field_1) + ceil32(s) + stor14.length.field_1 + 224] = mem[ceil32(stor14.length.field_1) + ceil32(s) + 160]
              mem[mem[ceil32(stor14.length.field_1) + 128] + ceil32(stor14.length.field_1) + ceil32(s) + stor14.length.field_1 + 256 len ceil32(_1424)] = mem[ceil32(stor14.length.field_1) + ceil32(s) + 192 len ceil32(_1424)]
              mem[_1424 + mem[ceil32(stor14.length.field_1) + 128] + ceil32(stor14.length.field_1) + ceil32(s) + stor14.length.field_1 + 256] = 0
              return 32, mem[mem[ceil32(stor14.length.field_1) + 128] + ceil32(stor14.length.field_1) + ceil32(s) + stor14.length.field_1 + 224 len ceil32(_1424) + 32], 
          mem[ceil32(stor14.length.field_1) + 160 len s] = call.data[calldata.size len s]
          t = s
          idx = _tokenId
          while idx:
              if t - 1 > t:
                  revert with 0, 17
              if 48 > (idx % 10) + 48:
                  revert with 0, 17
              if t - 1 >= mem[ceil32(stor14.length.field_1) + 128]:
                  revert with 0, 50
              mem[t + ceil32(stor14.length.field_1) + 159 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
              t = t - 1
              idx = idx / 10
              continue 
          mem[ceil32(stor14.length.field_1) + ceil32(s) + 192 len ceil32(stor14.length.field_1)] = mem[128 len ceil32(stor14.length.field_1)]
          mem[stor14.length.field_1 + ceil32(stor14.length.field_1) + ceil32(s) + 192] = 0
          mem[ceil32(stor14.length.field_1) + ceil32(s) + stor14.length.field_1 + 192 len ceil32(mem[ceil32(stor14.length.field_1) + 128])] = mem[ceil32(stor14.length.field_1) + 160 len ceil32(mem[ceil32(stor14.length.field_1) + 128])]
          mem[64] = mem[ceil32(stor14.length.field_1) + 128] + ceil32(stor14.length.field_1) + ceil32(s) + stor14.length.field_1 + 192
          mem[mem[ceil32(stor14.length.field_1) + 128] + ceil32(stor14.length.field_1) + ceil32(s) + stor14.length.field_1 + 192] = 32
          _1425 = mem[ceil32(stor14.length.field_1) + ceil32(s) + 160]
          mem[mem[ceil32(stor14.length.field_1) + 128] + ceil32(stor14.length.field_1) + ceil32(s) + stor14.length.field_1 + 224] = mem[ceil32(stor14.length.field_1) + ceil32(s) + 160]
          mem[mem[ceil32(stor14.length.field_1) + 128] + ceil32(stor14.length.field_1) + ceil32(s) + stor14.length.field_1 + 256 len ceil32(_1425)] = mem[ceil32(stor14.length.field_1) + ceil32(s) + 192 len ceil32(_1425)]
          mem[_1425 + mem[ceil32(stor14.length.field_1) + 128] + ceil32(stor14.length.field_1) + ceil32(s) + stor14.length.field_1 + 256] = 0
          return 32, mem[mem[ceil32(stor14.length.field_1) + 128] + ceil32(stor14.length.field_1) + ceil32(s) + stor14.length.field_1 + 224 len ceil32(_1425) + 32], 
      mem[0] = 14
      mem[128] = uint256(stor14.field_0)
      idx = 128
      s = 0
      while (uint255(stor14.length) * 0.5) + 96 > idx:
          mem[idx + 32] = stor14[s].field_256
          idx = idx + 32
          s = s + 1
          continue 
      if stor14.length.field_1 <= 0:
          return ''
      if not -_tokenId:
          mem[ceil32(stor14.length.field_1) + 224 len ceil32(stor14.length.field_1)] = mem[128 len ceil32(stor14.length.field_1)]
          mem[ceil32(stor14.length.field_1) + stor14.length.field_1 + 224] = 0x3000000000000000000000000000000000000000000000000000000000000000
          mem[ceil32(stor14.length.field_1) + stor14.length.field_1 + 225] = 32
          mem[ceil32(stor14.length.field_1) + stor14.length.field_1 + 257] = mem[ceil32(stor14.length.field_1) + 192]
          mem[ceil32(stor14.length.field_1) + stor14.length.field_1 + 289 len ceil32(mem[ceil32(stor14.length.field_1) + 192])] = mem[ceil32(stor14.length.field_1) + 224 len ceil32(mem[ceil32(stor14.length.field_1) + 192])]
          mem[mem[ceil32(stor14.length.field_1) + 192] + ceil32(stor14.length.field_1) + stor14.length.field_1 + 289] = 0
          return Array(len=mem[ceil32(stor14.length.field_1) + 192], data=mem[ceil32(stor14.length.field_1) + stor14.length.field_1 + 289 len ceil32(mem[ceil32(stor14.length.field_1) + 192])]), 
      s = 0
      idx = _tokenId
      while idx:
          if not s + 1:
              revert with 0, 17
          s = s + 1
          idx = idx / 10
          continue 
      if s > 18446744073709551615:
          revert with 0, 65
      mem[ceil32(stor14.length.field_1) + 128] = s
      if not s:
          t = s
          idx = _tokenId
          while idx:
              if t - 1 > t:
                  revert with 0, 17
              if 48 > (idx % 10) + 48:
                  revert with 0, 17
              if t - 1 >= mem[ceil32(stor14.length.field_1) + 128]:
                  revert with 0, 50
              mem[t + ceil32(stor14.length.field_1) + 159 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
              t = t - 1
              idx = idx / 10
              continue 
          mem[ceil32(stor14.length.field_1) + ceil32(s) + 192 len ceil32(stor14.length.field_1)] = mem[128 len ceil32(stor14.length.field_1)]
          mem[stor14.length.field_1 + ceil32(stor14.length.field_1) + ceil32(s) + 192] = 0
          mem[ceil32(stor14.length.field_1) + ceil32(s) + stor14.length.field_1 + 192 len ceil32(mem[ceil32(stor14.length.field_1) + 128])] = mem[ceil32(stor14.length.field_1) + 160 len ceil32(mem[ceil32(stor14.length.field_1) + 128])]
          mem[64] = mem[ceil32(stor14.length.field_1) + 128] + ceil32(stor14.length.field_1) + ceil32(s) + stor14.length.field_1 + 192
          mem[mem[ceil32(stor14.length.field_1) + 128] + ceil32(stor14.length.field_1) + ceil32(s) + stor14.length.field_1 + 192] = 32
          _1562 = mem[ceil32(stor14.length.field_1) + ceil32(s) + 160]
          mem[mem[ceil32(stor14.length.field_1) + 128] + ceil32(stor14.length.field_1) + ceil32(s) + stor14.length.field_1 + 224] = mem[ceil32(stor14.length.field_1) + ceil32(s) + 160]
          mem[mem[ceil32(stor14.length.field_1) + 128] + ceil32(stor14.length.field_1) + ceil32(s) + stor14.length.field_1 + 256 len ceil32(_1562)] = mem[ceil32(stor14.length.field_1) + ceil32(s) + 192 len ceil32(_1562)]
          mem[_1562 + mem[ceil32(stor14.length.field_1) + 128] + ceil32(stor14.length.field_1) + ceil32(s) + stor14.length.field_1 + 256] = 0
          return 32, mem[mem[ceil32(stor14.length.field_1) + 128] + ceil32(stor14.length.field_1) + ceil32(s) + stor14.length.field_1 + 224 len ceil32(_1562) + 32], 
      mem[ceil32(stor14.length.field_1) + 160 len s] = call.data[calldata.size len s]
      t = s
      idx = _tokenId
      while idx:
          if t - 1 > t:
              revert with 0, 17
          if 48 > (idx % 10) + 48:
              revert with 0, 17
          if t - 1 >= mem[ceil32(stor14.length.field_1) + 128]:
              revert with 0, 50
          mem[t + ceil32(stor14.length.field_1) + 159 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
          t = t - 1
          idx = idx / 10
          continue 
      mem[ceil32(stor14.length.field_1) + ceil32(s) + 192 len ceil32(stor14.length.field_1)] = mem[128 len ceil32(stor14.length.field_1)]
      mem[stor14.length.field_1 + ceil32(stor14.length.field_1) + ceil32(s) + 192] = 0
      mem[ceil32(stor14.length.field_1) + ceil32(s) + stor14.length.field_1 + 192 len ceil32(mem[ceil32(stor14.length.field_1) + 128])] = mem[ceil32(stor14.length.field_1) + 160 len ceil32(mem[ceil32(stor14.length.field_1) + 128])]
      mem[64] = mem[ceil32(stor14.length.field_1) + 128] + ceil32(stor14.length.field_1) + ceil32(s) + stor14.length.field_1 + 192
      mem[mem[ceil32(stor14.length.field_1) + 128] + ceil32(stor14.length.field_1) + ceil32(s) + stor14.length.field_1 + 192] = 32
      _1563 = mem[ceil32(stor14.length.field_1) + ceil32(s) + 160]
      mem[mem[ceil32(stor14.length.field_1) + 128] + ceil32(stor14.length.field_1) + ceil32(s) + stor14.length.field_1 + 224] = mem[ceil32(stor14.length.field_1) + ceil32(s) + 160]
      mem[mem[ceil32(stor14.length.field_1) + 128] + ceil32(stor14.length.field_1) + ceil32(s) + stor14.length.field_1 + 256 len ceil32(_1563)] = mem[ceil32(stor14.length.field_1) + ceil32(s) + 192 len ceil32(_1563)]
      mem[_1563 + mem[ceil32(stor14.length.field_1) + 128] + ceil32(stor14.length.field_1) + ceil32(s) + stor14.length.field_1 + 256] = 0
      return 32, mem[mem[ceil32(stor14.length.field_1) + 128] + ceil32(stor14.length.field_1) + ceil32(s) + stor14.length.field_1 + 224 len ceil32(_1563) + 32], 
  if not bool(stor14.length) - (stor14.length.field_1 < 32):
      revert with 0, 34
  if not stor14.length.field_1:
      if stor14.length.field_1 <= 0:
          return ''
      if not -_tokenId:
          mem[ceil32(stor14.length.field_1) + 224 len ceil32(stor14.length.field_1)] = mem[128 len ceil32(stor14.length.field_1)]
          mem[ceil32(stor14.length.field_1) + stor14.length.field_1 + 224] = 0x3000000000000000000000000000000000000000000000000000000000000000
          mem[ceil32(stor14.length.field_1) + stor14.length.field_1 + 225] = 32
          mem[ceil32(stor14.length.field_1) + stor14.length.field_1 + 257] = mem[ceil32(stor14.length.field_1) + 192]
          mem[ceil32(stor14.length.field_1) + stor14.length.field_1 + 289 len ceil32(mem[ceil32(stor14.length.field_1) + 192])] = mem[ceil32(stor14.length.field_1) + 224 len ceil32(mem[ceil32(stor14.length.field_1) + 192])]
          mem[mem[ceil32(stor14.length.field_1) + 192] + ceil32(stor14.length.field_1) + stor14.length.field_1 + 289] = 0
          return Array(len=mem[ceil32(stor14.length.field_1) + 192], data=mem[ceil32(stor14.length.field_1) + stor14.length.field_1 + 289 len ceil32(mem[ceil32(stor14.length.field_1) + 192])]), 
      s = 0
      idx = _tokenId
      while idx:
          if not s + 1:
              revert with 0, 17
          s = s + 1
          idx = idx / 10
          continue 
      if s > 18446744073709551615:
          revert with 0, 65
      mem[ceil32(stor14.length.field_1) + 128] = s
      if not s:
          t = s
          idx = _tokenId
          while idx:
              if t - 1 > t:
                  revert with 0, 17
              if 48 > (idx % 10) + 48:
                  revert with 0, 17
              if t - 1 >= mem[ceil32(stor14.length.field_1) + 128]:
                  revert with 0, 50
              mem[t + ceil32(stor14.length.field_1) + 159 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
              t = t - 1
              idx = idx / 10
              continue 
          mem[ceil32(stor14.length.field_1) + ceil32(s) + 192 len ceil32(stor14.length.field_1)] = mem[128 len ceil32(stor14.length.field_1)]
          mem[stor14.length.field_1 + ceil32(stor14.length.field_1) + ceil32(s) + 192] = 0
          mem[ceil32(stor14.length.field_1) + ceil32(s) + stor14.length.field_1 + 192 len ceil32(mem[ceil32(stor14.length.field_1) + 128])] = mem[ceil32(stor14.length.field_1) + 160 len ceil32(mem[ceil32(stor14.length.field_1) + 128])]
          mem[64] = mem[ceil32(stor14.length.field_1) + 128] + ceil32(stor14.length.field_1) + ceil32(s) + stor14.length.field_1 + 192
          mem[mem[ceil32(stor14.length.field_1) + 128] + ceil32(stor14.length.field_1) + ceil32(s) + stor14.length.field_1 + 192] = 32
          _1426 = mem[ceil32(stor14.length.field_1) + ceil32(s) + 160]
          mem[mem[ceil32(stor14.length.field_1) + 128] + ceil32(stor14.length.field_1) + ceil32(s) + stor14.length.field_1 + 224] = mem[ceil32(stor14.length.field_1) + ceil32(s) + 160]
          mem[mem[ceil32(stor14.length.field_1) + 128] + ceil32(stor14.length.field_1) + ceil32(s) + stor14.length.field_1 + 256 len ceil32(_1426)] = mem[ceil32(stor14.length.field_1) + ceil32(s) + 192 len ceil32(_1426)]
          mem[_1426 + mem[ceil32(stor14.length.field_1) + 128] + ceil32(stor14.length.field_1) + ceil32(s) + stor14.length.field_1 + 256] = 0
          return 32, mem[mem[ceil32(stor14.length.field_1) + 128] + ceil32(stor14.length.field_1) + ceil32(s) + stor14.length.field_1 + 224 len ceil32(_1426) + 32], 
      mem[ceil32(stor14.length.field_1) + 160 len s] = call.data[calldata.size len s]
      t = s
      idx = _tokenId
      while idx:
          if t - 1 > t:
              revert with 0, 17
          if 48 > (idx % 10) + 48:
              revert with 0, 17
          if t - 1 >= mem[ceil32(stor14.length.field_1) + 128]:
              revert with 0, 50
          mem[t + ceil32(stor14.length.field_1) + 159 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
          t = t - 1
          idx = idx / 10
          continue 
      mem[ceil32(stor14.length.field_1) + ceil32(s) + 192 len ceil32(stor14.length.field_1)] = mem[128 len ceil32(stor14.length.field_1)]
      mem[stor14.length.field_1 + ceil32(stor14.length.field_1) + ceil32(s) + 192] = 0
      mem[ceil32(stor14.length.field_1) + ceil32(s) + stor14.length.field_1 + 192 len ceil32(mem[ceil32(stor14.length.field_1) + 128])] = mem[ceil32(stor14.length.field_1) + 160 len ceil32(mem[ceil32(stor14.length.field_1) + 128])]
      mem[64] = mem[ceil32(stor14.length.field_1) + 128] + ceil32(stor14.length.field_1) + ceil32(s) + stor14.length.field_1 + 192
      mem[mem[ceil32(stor14.length.field_1) + 128] + ceil32(stor14.length.field_1) + ceil32(s) + stor14.length.field_1 + 192] = 32
      _1427 = mem[ceil32(stor14.length.field_1) + ceil32(s) + 160]
      mem[mem[ceil32(stor14.length.field_1) + 128] + ceil32(stor14.length.field_1) + ceil32(s) + stor14.length.field_1 + 224] = mem[ceil32(stor14.length.field_1) + ceil32(s) + 160]
      mem[mem[ceil32(stor14.length.field_1) + 128] + ceil32(stor14.length.field_1) + ceil32(s) + stor14.length.field_1 + 256 len ceil32(_1427)] = mem[ceil32(stor14.length.field_1) + ceil32(s) + 192 len ceil32(_1427)]
      mem[_1427 + mem[ceil32(stor14.length.field_1) + 128] + ceil32(stor14.length.field_1) + ceil32(s) + stor14.length.field_1 + 256] = 0
      return 32, mem[mem[ceil32(stor14.length.field_1) + 128] + ceil32(stor14.length.field_1) + ceil32(s) + stor14.length.field_1 + 224 len ceil32(_1427) + 32], 
  if 31 >= stor14.length.field_1:
      mem[128] = 256 * stor14.length.field_8
      if stor14.length.field_1 <= 0:
          return ''
      if not -_tokenId:
          mem[ceil32(stor14.length.field_1) + 224 len ceil32(stor14.length.field_1)] = mem[128 len ceil32(stor14.length.field_1)]
          mem[ceil32(stor14.length.field_1) + stor14.length.field_1 + 224] = 0x3000000000000000000000000000000000000000000000000000000000000000
          mem[ceil32(stor14.length.field_1) + stor14.length.field_1 + 225] = 32
          mem[ceil32(stor14.length.field_1) + stor14.length.field_1 + 257] = mem[ceil32(stor14.length.field_1) + 192]
          mem[ceil32(stor14.length.field_1) + stor14.length.field_1 + 289 len ceil32(mem[ceil32(stor14.length.field_1) + 192])] = mem[ceil32(stor14.length.field_1) + 224 len ceil32(mem[ceil32(stor14.length.field_1) + 192])]
          mem[mem[ceil32(stor14.length.field_1) + 192] + ceil32(stor14.length.field_1) + stor14.length.field_1 + 289] = 0
          return Array(len=mem[ceil32(stor14.length.field_1) + 192], data=mem[ceil32(stor14.length.field_1) + stor14.length.field_1 + 289 len ceil32(mem[ceil32(stor14.length.field_1) + 192])]), 
      s = 0
      idx = _tokenId
      while idx:
          if not s + 1:
              revert with 0, 17
          s = s + 1
          idx = idx / 10
          continue 
      if s > 18446744073709551615:
          revert with 0, 65
      mem[ceil32(stor14.length.field_1) + 128] = s
      if not s:
          t = s
          idx = _tokenId
          while idx:
              if t - 1 > t:
                  revert with 0, 17
              if 48 > (idx % 10) + 48:
                  revert with 0, 17
              if t - 1 >= mem[ceil32(stor14.length.field_1) + 128]:
                  revert with 0, 50
              mem[t + ceil32(stor14.length.field_1) + 159 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
              t = t - 1
              idx = idx / 10
              continue 
          mem[ceil32(stor14.length.field_1) + ceil32(s) + 192 len ceil32(stor14.length.field_1)] = mem[128 len ceil32(stor14.length.field_1)]
          mem[stor14.length.field_1 + ceil32(stor14.length.field_1) + ceil32(s) + 192] = 0
          mem[ceil32(stor14.length.field_1) + ceil32(s) + stor14.length.field_1 + 192 len ceil32(mem[ceil32(stor14.length.field_1) + 128])] = mem[ceil32(stor14.length.field_1) + 160 len ceil32(mem[ceil32(stor14.length.field_1) + 128])]
          mem[64] = mem[ceil32(stor14.length.field_1) + 128] + ceil32(stor14.length.field_1) + ceil32(s) + stor14.length.field_1 + 192
          mem[mem[ceil32(stor14.length.field_1) + 128] + ceil32(stor14.length.field_1) + ceil32(s) + stor14.length.field_1 + 192] = 32
          _1428 = mem[ceil32(stor14.length.field_1) + ceil32(s) + 160]
          mem[mem[ceil32(stor14.length.field_1) + 128] + ceil32(stor14.length.field_1) + ceil32(s) + stor14.length.field_1 + 224] = mem[ceil32(stor14.length.field_1) + ceil32(s) + 160]
          mem[mem[ceil32(stor14.length.field_1) + 128] + ceil32(stor14.length.field_1) + ceil32(s) + stor14.length.field_1 + 256 len ceil32(_1428)] = mem[ceil32(stor14.length.field_1) + ceil32(s) + 192 len ceil32(_1428)]
          mem[_1428 + mem[ceil32(stor14.length.field_1) + 128] + ceil32(stor14.length.field_1) + ceil32(s) + stor14.length.field_1 + 256] = 0
          return 32, mem[mem[ceil32(stor14.length.field_1) + 128] + ceil32(stor14.length.field_1) + ceil32(s) + stor14.length.field_1 + 224 len ceil32(_1428) + 32], 
      mem[ceil32(stor14.length.field_1) + 160 len s] = call.data[calldata.size len s]
      t = s
      idx = _tokenId
      while idx:
          if t - 1 > t:
              revert with 0, 17
          if 48 > (idx % 10) + 48:
              revert with 0, 17
          if t - 1 >= mem[ceil32(stor14.length.field_1) + 128]:
              revert with 0, 50
          mem[t + ceil32(stor14.length.field_1) + 159 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
          t = t - 1
          idx = idx / 10
          continue 
      mem[ceil32(stor14.length.field_1) + ceil32(s) + 192 len ceil32(stor14.length.field_1)] = mem[128 len ceil32(stor14.length.field_1)]
      mem[stor14.length.field_1 + ceil32(stor14.length.field_1) + ceil32(s) + 192] = 0
      mem[ceil32(stor14.length.field_1) + ceil32(s) + stor14.length.field_1 + 192 len ceil32(mem[ceil32(stor14.length.field_1) + 128])] = mem[ceil32(stor14.length.field_1) + 160 len ceil32(mem[ceil32(stor14.length.field_1) + 128])]
      mem[64] = mem[ceil32(stor14.length.field_1) + 128] + ceil32(stor14.length.field_1) + ceil32(s) + stor14.length.field_1 + 192
      mem[mem[ceil32(stor14.length.field_1) + 128] + ceil32(stor14.length.field_1) + ceil32(s) + stor14.length.field_1 + 192] = 32
      _1429 = mem[ceil32(stor14.length.field_1) + ceil32(s) + 160]
      mem[mem[ceil32(stor14.length.field_1) + 128] + ceil32(stor14.length.field_1) + ceil32(s) + stor14.length.field_1 + 224] = mem[ceil32(stor14.length.field_1) + ceil32(s) + 160]
      mem[mem[ceil32(stor14.length.field_1) + 128] + ceil32(stor14.length.field_1) + ceil32(s) + stor14.length.field_1 + 256 len ceil32(_1429)] = mem[ceil32(stor14.length.field_1) + ceil32(s) + 192 len ceil32(_1429)]
      mem[_1429 + mem[ceil32(stor14.length.field_1) + 128] + ceil32(stor14.length.field_1) + ceil32(s) + stor14.length.field_1 + 256] = 0
      return 32, mem[mem[ceil32(stor14.length.field_1) + 128] + ceil32(stor14.length.field_1) + ceil32(s) + stor14.length.field_1 + 224 len ceil32(_1429) + 32], 
  mem[0] = 14
  mem[128] = uint256(stor14.field_0)
  idx = 128
  s = 0
  while stor14.length.field_1 + 96 > idx:
      mem[idx + 32] = stor14[s].field_256
      idx = idx + 32
      s = s + 1
      continue 
  if stor14.length.field_1 <= 0:
      return ''
  if not -_tokenId:
      mem[ceil32(stor14.length.field_1) + 224 len ceil32(stor14.length.field_1)] = mem[128 len ceil32(stor14.length.field_1)]
      mem[ceil32(stor14.length.field_1) + stor14.length.field_1 + 224] = 0x3000000000000000000000000000000000000000000000000000000000000000
      mem[ceil32(stor14.length.field_1) + stor14.length.field_1 + 225] = 32
      mem[ceil32(stor14.length.field_1) + stor14.length.field_1 + 257] = mem[ceil32(stor14.length.field_1) + 192]
      mem[ceil32(stor14.length.field_1) + stor14.length.field_1 + 289 len ceil32(mem[ceil32(stor14.length.field_1) + 192])] = mem[ceil32(stor14.length.field_1) + 224 len ceil32(mem[ceil32(stor14.length.field_1) + 192])]
      mem[mem[ceil32(stor14.length.field_1) + 192] + ceil32(stor14.length.field_1) + stor14.length.field_1 + 289] = 0
      return Array(len=mem[ceil32(stor14.length.field_1) + 192], data=mem[ceil32(stor14.length.field_1) + stor14.length.field_1 + 289 len ceil32(mem[ceil32(stor14.length.field_1) + 192])]), 
  s = 0
  idx = _tokenId
  while idx:
      if not s + 1:
          revert with 0, 17
      s = s + 1
      idx = idx / 10
      continue 
  if s > 18446744073709551615:
      revert with 0, 65
  mem[ceil32(stor14.length.field_1) + 128] = s
  if not s:
      t = s
      idx = _tokenId
      while idx:
          if t - 1 > t:
              revert with 0, 17
          if 48 > (idx % 10) + 48:
              revert with 0, 17
          if t - 1 >= mem[ceil32(stor14.length.field_1) + 128]:
              revert with 0, 50
          mem[t + ceil32(stor14.length.field_1) + 159 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
          t = t - 1
          idx = idx / 10
          continue 
      mem[ceil32(stor14.length.field_1) + ceil32(s) + 192 len ceil32(stor14.length.field_1)] = mem[128 len ceil32(stor14.length.field_1)]
      mem[stor14.length.field_1 + ceil32(stor14.length.field_1) + ceil32(s) + 192] = 0
      mem[ceil32(stor14.length.field_1) + ceil32(s) + stor14.length.field_1 + 192 len ceil32(mem[ceil32(stor14.length.field_1) + 128])] = mem[ceil32(stor14.length.field_1) + 160 len ceil32(mem[ceil32(stor14.length.field_1) + 128])]
      mem[64] = mem[ceil32(stor14.length.field_1) + 128] + ceil32(stor14.length.field_1) + ceil32(s) + stor14.length.field_1 + 192
      mem[mem[ceil32(stor14.length.field_1) + 128] + ceil32(stor14.length.field_1) + ceil32(s) + stor14.length.field_1 + 192] = 32
      _1564 = mem[ceil32(stor14.length.field_1) + ceil32(s) + 160]
      mem[mem[ceil32(stor14.length.field_1) + 128] + ceil32(stor14.length.field_1) + ceil32(s) + stor14.length.field_1 + 224] = mem[ceil32(stor14.length.field_1) + ceil32(s) + 160]
      mem[mem[ceil32(stor14.length.field_1) + 128] + ceil32(stor14.length.field_1) + ceil32(s) + stor14.length.field_1 + 256 len ceil32(_1564)] = mem[ceil32(stor14.length.field_1) + ceil32(s) + 192 len ceil32(_1564)]
      mem[_1564 + mem[ceil32(stor14.length.field_1) + 128] + ceil32(stor14.length.field_1) + ceil32(s) + stor14.length.field_1 + 256] = 0
      return 32, mem[mem[ceil32(stor14.length.field_1) + 128] + ceil32(stor14.length.field_1) + ceil32(s) + stor14.length.field_1 + 224 len ceil32(_1564) + 32], 
  mem[ceil32(stor14.length.field_1) + 160 len s] = call.data[calldata.size len s]
  t = s
  idx = _tokenId
  while idx:
      if t - 1 > t:
          revert with 0, 17
      if 48 > (idx % 10) + 48:
          revert with 0, 17
      if t - 1 >= mem[ceil32(stor14.length.field_1) + 128]:
          revert with 0, 50
      mem[t + ceil32(stor14.length.field_1) + 159 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
      t = t - 1
      idx = idx / 10
      continue 
  mem[ceil32(stor14.length.field_1) + ceil32(s) + 192 len ceil32(stor14.length.field_1)] = mem[128 len ceil32(stor14.length.field_1)]
  mem[stor14.length.field_1 + ceil32(stor14.length.field_1) + ceil32(s) + 192] = 0
  mem[ceil32(stor14.length.field_1) + ceil32(s) + stor14.length.field_1 + 192 len ceil32(mem[ceil32(stor14.length.field_1) + 128])] = mem[ceil32(stor14.length.field_1) + 160 len ceil32(mem[ceil32(stor14.length.field_1) + 128])]
  mem[64] = mem[ceil32(stor14.length.field_1) + 128] + ceil32(stor14.length.field_1) + ceil32(s) + stor14.length.field_1 + 192
  mem[mem[ceil32(stor14.length.field_1) + 128] + ceil32(stor14.length.field_1) + ceil32(s) + stor14.length.field_1 + 192] = 32
  _1565 = mem[ceil32(stor14.length.field_1) + ceil32(s) + 160]
  mem[mem[ceil32(stor14.length.field_1) + 128] + ceil32(stor14.length.field_1) + ceil32(s) + stor14.length.field_1 + 224] = mem[ceil32(stor14.length.field_1) + ceil32(s) + 160]
  mem[mem[ceil32(stor14.length.field_1) + 128] + ceil32(stor14.length.field_1) + ceil32(s) + stor14.length.field_1 + 256 len ceil32(_1565)] = mem[ceil32(stor14.length.field_1) + ceil32(s) + 192 len ceil32(_1565)]
  mem[_1565 + mem[ceil32(stor14.length.field_1) + 128] + ceil32(stor14.length.field_1) + ceil32(s) + stor14.length.field_1 + 256] = 0
  return 32, mem[mem[ceil32(stor14.length.field_1) + 128] + ceil32(stor14.length.field_1) + ceil32(s) + stor14.length.field_1 + 224 len ceil32(_1565) + 32], 

